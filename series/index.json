[{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":0,"section":"","tags":null,"title":"About","uri":"https://sssylvan.github.io/about/"},{"content":" HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 HTTP 旨在尽可能多地缓存，面对缓存这道难题，在项目上线前缓存策略是必须考虑和配置好的：\n一次性资源，设置尽可能大的 max-age 会变更资源，设置 no-cache 能确定时效，设置 Expires、must-revalidate，注意与 max-age 的冲突 此外，在配置 Web 服务器消息头时，还有 🛡️ 安全相关 的设置需要注意： https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":1,"section":"posts","tags":null,"title":"HTTP 缓存实践总结","uri":"https://sssylvan.github.io/posts/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":" Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用 hugo 生成静态博客并部署在 GitHub 上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":2,"section":"posts","tags":null,"title":"Hugo + Github Pages 搭建个人博客","uri":"https://sssylvan.github.io/posts/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"content":" 最近看到了两位大佬天花板级别的类型体操：\n用 TypeScript 类型运算实现一个中国象棋程序 - 徐飞 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器 - brambles 看完只能献上我的 🧎‍♂️。网上也出现一些 type-challenges 上的面试骚题，大部分是考察 infer 的应用。\n实际项目中，抽象不同业务的相同流程时，我有使用 infer 推断具体业务类型。infer 的强大在于可以通过模式匹配可以从泛型中提取到类型，总结有 4 种场景：\n对象属性类型 函数参数类型和返回值类型 Function Parameters and Return type 数组 Array 模板字符串 Template Literals 使用前注意：infer 只能出现 extends 条件类型1 语句中，且类型变量只能在 true 分支中使用。\n条件类型语法有点像 JavaScript 的三元运算 (condition ? trueExpression : falseExpression) ：\n1 SomeType extends OtherType ? TrueType : FalseType; 对象属性 condition 的写法是属性作为 key，值使用 infer ：{ prop : infer V }。下面代码从通用的接口类型中获取 todo 数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 interface ApiResponse\u0026lt;T\u0026gt; { code: number data: T } interface Todo { content: string completed: boolean } type TodosResp = ApiResponse\u0026lt;Todo[]\u0026gt; type GetRespData\u0026lt;T\u0026gt; = T extends { data: infer V } ? V : never type DataInTodoResp = GetRespData\u0026lt;TodosResp\u0026gt; // Todo[] 函数参数和返回值 写出函数类型声明 (...args: any[]) =\u0026gt; any 然后填空即可\n返回值类型\n1 type MyReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : never 参数类型\n1 2 3 4 5 type MyParameters\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...any: infer P ) =\u0026gt; any ? P : never 数组 一类仍然是模式匹配，通过解构赋值2，取数组第一个/最后一个的类型\n1 2 type First\u0026lt;T extends any[]\u0026gt; = T extends [infer F, ...any[]] ? F : never type Last\u0026lt;T extends any[]\u0026gt; = T extends [...any[], infer L] ? L : never 一类要使用递归，在类型系统中实现 JavaScript Array.includes 函数，解构取到第一个元素和由剩余元素组成的数组，第一个匹配成功返回 true，未匹配成功继续用剩下的数组匹配。\ntype Includes\u0026lt;T extends readonly any[], U\u0026gt; = T extends [infer F,...infer R] ? (Equal\u0026lt;F,U\u0026gt; extends true ? true : Includes\u0026lt;R,U\u0026gt;) : false 模板字符串 删除两段的空白字符串 Trim，解法是模板模式配合递归\n1 2 3 4 5 6 type Chars = \u0026#39; \u0026#39; | \u0026#39;\\n\u0026#39; | \u0026#39;\\t\u0026#39; type Trim\u0026lt;S extends string\u0026gt; = S extends `${Chars}${infer SS}` ? Trim\u0026lt;SS\u0026gt; : S extends `${infer SS}${Chars}` ? Trim\u0026lt;SS\u0026gt; : S 总结 4 个场景捋下来，使用 infer 提取类型的关键在于写出符合不同数据结构的模式，然后填空即可。日常业务开发，这些袋鼠摇基本够用了~ 🦘\nhttps://www.typescriptlang.org/docs/handbook/2/conditional-types.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":3,"section":"posts","tags":null,"title":"Typescript 使用 infer 的4种场景","uri":"https://sssylvan.github.io/posts/typescript-%E4%BD%BF%E7%94%A8-infer-%E7%9A%844%E7%A7%8D%E5%9C%BA%E6%99%AF/"},{"content":"🧑‍🤝‍🧑 undefined 和 null 那些事 在 Javascript 中，undefined 和 null 是若即若离的空值两兄弟 🧑‍🤝‍🧑（nullish value1）。我们有时候把它们视为两个不同的概念，有时候又把它们作相同的处理。\n概念不同 从数据角度讲，两者完全是两个概念：\nundefined 表示值不存在。内存空间找不到变量对应的值 null 则是一个字面量“空”。变量指向内存里表示“空”的地址 下面这张图能直观看到两者的差异：\n2\n给函数参数的设置默认值只对 undefined 生效\n1 2 3 4 5 6 7 function test(num = 1) { console.log(typeof num); } test(); // \u0026#39;number\u0026#39; (num is set to 1) test(undefined); // \u0026#39;number\u0026#39; (num is set to 1 too) test(null); // \u0026#39;object\u0026#39; (num is set to null) 实际业务中也有区分的场景，比如表单有一数值项，用户不输入和输入后清空，页面显示该项都为空，但是前者表示用户没有任何操作，后者则表示用户填写值是 null。\nNullish 家族 一般情况下， ==（The Abstract Equality Comparison Algorithm 3）在比较前将两个被比较的值转换为相同类型。但 null == undefined 是特例，它俩的抽象相等比较的结果是 true。\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:\nIf x is null and y is undefined, return true. If x is undefined and y is null, return true. 两兄弟认祖归宗 Nullish 家族 👨‍❤️‍💋‍👨。Nullish 家族目前有3个技能：空值合并操作符 ??（Nullish coalescing operator4）、空值合并赋值 ??=（Nullish coalescing assignment）、可选链 (?.)（Optional chaining）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Nullish coalescing operator const foo = null ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; const boo= undefined ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; // Nullish coalescing assignment const a = {duration:null} a.duration ??= 10 a.speed ??= 25 a // {duration: 10, speed: 25} // Optional chaining const greet = null greet?.() // undefined const sing = undefined sing?.() // undefined 把它们放到一个家族里，个人感觉是为了精简啰嗦的判断语法，Nullish 家族的技能都可用其它方式实现。但因为实际业务中它俩同时出现的频率实在太高，索性整合到一起。\n比如表单有一数值项和根据该数值计算得到的结果。数值是 null 和 undefined 时可能不显示结果。\nundefined 的历史 以下内容截取至 undefined与null的区别 - 阮一峰\n1995年JavaScript诞生之初像 Java 一样，只设置了 null 作为表示\u0026quot;无\u0026quot;的值。\n根据C语言的传统，null 被设计成可以自动转为 0。\n1 2 Number(null) // 0 5 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。\n首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示\u0026quot;无\u0026quot;的值最好不是对象。\n其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果 null 自动转为 0，很不容易发现错误。\n因此，Brendan Eich又设计了一个 undefined。\nJavascript 设计之初是运行在客户端的动态解释型语言，对数据没有约束力，所以也需要有不存在这一概念。\n有点奇怪的 null 奇怪的类型，null 是原始类型（primitive ）中的一员，但 typeof null 的结果是 object。嘿，这其实是大佬留下的一坨 💩5。JavaScript 值包含类型标记和值。 000 表示对象类型，而 null 刚好是 32个 0 。\n不行，这坨我吃不下。一定要拿到 null 类型（当然也可以用 === strict equality）\n1 Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; 奇怪的数值转换，这是只能吃的一坨~ 6\n1 2 Number(null) // 0 null == 0 // false 原型链的的终点是 null 7\n1 Object.prototype.__proto__ // null 总结 undefined 和 null 从数据角度看，有本质的不同：null 是空值，undefined 是不存在。如果业务上需要明确区分，在提交数据时应该注意。而在客户端消费数据时，两个都是 无效值，可以使用 Nullish 家族技能，用更简洁的语法实现需求。\nhttps://developer.mozilla.org/en-US/docs/Glossary/Nullish\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-11.9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://2ality.com/2013/10/typeof-null.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/ecma262/#sec-properties-of-the-object-prototype-object\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":4,"section":"posts","tags":null,"title":"undefined 和 null  那些事","uri":"https://sssylvan.github.io/posts/undefined-%E5%92%8C-null-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]