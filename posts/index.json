[{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":0,"section":"","tags":null,"title":"About","uri":"https://sssylvan.github.io/about/"},{"content":"使用 Angular 开发项目有一段时间了，这期间经历了我司复杂业务流程的毒打，好在逐渐掌握 RxJS 之后，开始应对自如 🤹。现在回过头看，必须得夸一句：响应式编程真香。\n然而我初学 RxJS 的体验并不友好，概念太多了。一上来就是流（stream）、观察者模式、迭代器模式、Pull、Push、Hot、Cold、单播、多播\u0026hellip; 。得，还没开始用，先被一堆名词给绕晕了。\n我们可以先搞明白为什么要“响应式”？非响应式有什么缺点？这里我把非响应式编程称为事件单点（point）处理。\n事件单点处理 单点处理思维是一种快速而简单的思考方式。在编写事件处理代码时，写明需要执行的具体步骤，以实现最终的结果。下面以 TODO List 为案例，页面有一个待办事项列表，可以输入关键字过滤，还有一个“隐藏已完成”的复选框\n在从服务端获取到待办列表、用户输入关键字和点击复选框时，页面的列表项要显示筛选后的结果。下面是核心部分的代码实现，服务端获取用 Promise 简单模拟一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Component({ selector: \u0026#39;my-app\u0026#39;, standalone: true, imports: [CommonModule], template: ` \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;To Do List\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input placeholder=\u0026#34;keyword\u0026#34; (input)=\u0026#34;handleKeywordChange($event)\u0026#34; /\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; (input)=\u0026#34;handleHideCompleted($event)\u0026#34; /\u0026gt; hide completed \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of items\u0026#34; [class.done]=\u0026#34;item.done\u0026#34;\u0026gt; {{ item.description }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; `, styles: [\u0026#39;li.done { text-decoration: line-through;color:grey }\u0026#39;], }) export class PointDemo { keyword = \u0026#39;\u0026#39; completedHid = false items: Item[] = null allItems: Item[] = null ngOnInit() { // 模拟服务端获取 Promise.resolve([ { description: \u0026#39;eat\u0026#39;, done: true }, { description: \u0026#39;sleep\u0026#39;, done: false }, { description: \u0026#39;play\u0026#39;, done: false }, { description: \u0026#39;laugh\u0026#39;, done: true }, ]).then((res) =\u0026gt; { this.allItems = res this.filterItems() }) } handleKeywordChange(ev: any) { this.keyword = ev.target.value this.filterItems() } handleHideCompleted(ev: any) { this.completedHid = ev.target.checked this.filterItems() } private filterItems() { if (this.allItems) { this.items = this.allItems.filter( (item) =\u0026gt; item.description.includes(this.keyword) \u0026amp;\u0026amp; (this.completedHid ? !item.done : true) ) } } } 重复出现的 this.filterItems() 让人闻到了不好的味道。每个事件发生后，变更相应的数据，然后按新的数据重新筛选待办列表。数据的消费过程，只能写在事件处理函数中。\n这就好比餐厅的厨师炒完一道菜，还要上菜，或者打包成外卖，或者做其他处理。这样厨师的压力会很大，一旦忙起来很容易出错。\n同样的，事件单点处理的方式，让事件处理函数的压力会随着需求增多而加大。数据的生产和消费耦合在了一起。\n响应式改造 在现实生活中，餐厅会配备服务员。厨师炒完菜，把菜放上餐台，服务员看到后会去上菜或打包，完成后续的步骤。这样厨师的压力大减。\n在 TODO List 例子中，我们也给它配备“餐台”和“服务员”试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 export class ObservableDemo { keyword$ = new BehaviorSubject(\u0026#39;\u0026#39;) completedHid$ = new BehaviorSubject(false) items: Item[] = null ngOnInit() { const allItems$ = from( Promise.resolve([ { description: \u0026#39;eat\u0026#39;, done: true }, { description: \u0026#39;sleep\u0026#39;, done: false }, { description: \u0026#39;play\u0026#39;, done: false }, { description: \u0026#39;laugh\u0026#39;, done: true }, ]) ) const waiter = ([allItems, keyword, completedHid]) =\u0026gt; { this.items = allItems.filter( (item) =\u0026gt; item.description.includes(keyword) \u0026amp;\u0026amp; (completedHid ? !item.done : true) ) } combineLatest([ allItems$, this.keyword$.asObservable(), this.completedHid$.asObservable(), ]).subscribe(waiter) } handleKeywordChange(ev: any) { this.keyword$.next(ev.target.value) } handleHideCompleted(ev: any) { this.completedHid$.next(ev.target.checked) } } （PS：以 $ 结尾是可观察对象的命名约定1）\n改造后增加了三个“餐台” 数据源，keyword$、completedHid$、allItems$，waiter 订阅这三个源，在接收到新数据时，重新过滤待办列表。同时在事件处理函数中，只需要发出新的数据。这样各司其职，就实现了生产数据和消费数据的解耦，代码逻辑更清晰易懂。\nAngular 提供了响应式表单 FormControl 和 异步 Pipe async，代码可以继续简化传送门\n现在可以回答最开始的提出的疑问，响应式编程的好处是：解耦，实现数据生产和消费的职能分离。\n升级流式思维 尝到了甜头，再来看看响应式编程的定义：响应式编程是一种面向数据流和变化传播的编程范式。\n数据流是把在时间上按顺序依次产生数据看作一个整体，它是一个可观察的序列。数据流的变化会自动地传播给依赖于它的组件，并触发相应的更新和反应。\nYour Mouse is a Database，RxJS 的作者 Erik Meijer 如是写到。\n客户端的职能是请求服务器数据和响应用户操作，通常响应结果 = 服务器数据 + 用户操作数据。但他们都是异步的，且一个是 XMLHttpRequest，一个是 Dom Event，两者并不能简单的相加。用 RxJS 把它们同化为“流”，就很好处理了。\n比如在之前 TODO List 改造案例中，就是把“列表的获取”、 “关键字的输入”、“复选框的点击” 当成 “请求流”、“输入流”和“点击流”，再通过 RxJS 提供合并操作符 combineLatest ，把分散的数据流合并到一起来使用，得到最终的响应结果，非常便利。\nRxJS 提供了 90 多种 操作符，可以对流进行创建、合并、拆分、转化等各种操作。“流”不代表一定得有多个数据，可以是一个，也可以是 EMPTY。把异步事件都当成流，才能发挥操作符的威力。\nPromise 经常被拿来和可观察序列（Observable）对比，它们都可以处理异步事件。但 Promise 在创建时立即执行，且最多只能提供一个值；而 Observable 是惰性的，有订阅才会执行，可以提供多个值。详见 Observables compared to promises。\n最后 关于响应式编程，不要纠结于它提出的各种概念，用它解决问题，优化代码，提升思维。当你足够熟练之后，那些概念自然而然就理解了。本文举了一个很简单的案例，实际开发中 RxJS 能让你轻松应对各种复杂场景。\nObservable 已经在 TC39 提案里了，虽然现在还是 Stage 1 征求意见阶段2。\nhttps://angular.io/guide/rx-library#naming-conventions-for-observables\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/proposal-observable/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":1,"section":"posts","tags":null,"title":"Angular RxJS 响应式编程","uri":"https://sssylvan.github.io/posts/angular-rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"content":" 最近重写了项目的支付中心组件。起因是项目经过几个月的开发和迭代，从开始的一种业务订单 + 一种支付方式，到现在变成了多种业务订单 + 多种支付方式 ，复杂度翻了几倍，原有的组件变得难以维护和扩展。刚好开发的新业务到了对接支付阶段，索性把它重写了。这次对复杂业务的重写让我深刻体会到了 Angular 依赖注入的强大和灵活 。\n业务场景 用户在我司网站上购买机票或者预订酒店，下单完成后会进到支付页面。支付页面根据用户信息获取其可用的支付方式，然后用户就可以按需选择支付方式完成支付。页面结构大体如图：\n订单页包含产品信息和支付中心组件，支付中心包含多个支付组件，可以切换支付方式，支付组件包含支付按钮。支付组件之间没有关联。当用户点下支付按钮时，大致会经过以下几个步骤：\n虚线部分表示不同产品/不同支付方式相应的流程会有差异， 😂 基本就没啥相同的。复杂程度 = 产品类型*支付方式\n实现方案 旧版的实现方案简单直接，把支付所需的订单信息层层传递到每个支付组件。这个方案的问题有两个：\n父组件依赖子组件的具体实现。支付组件有变更，订单组件要跟着改。 属性层层传递的写法啰嗦 依赖反转原则（Dependence Inversion Principle，DIP）提供了优化思路：\n高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 依赖抽象示意图：\n嗯，看似好像没啥问题。等等！光依赖抽象了，反转呢？没看到哪里有“反”啊。这里我只能感谢中文社区的翻译 😤。。来看 wikipedia 英文原版对 DIP 的解释（机翻）：\nA. 高级模块不应从低级模块导入任何内容。两者都应该依赖于抽象（例如，接口）。\nB. 抽象不应依赖于细节。细节（具体实现）应该取决于抽象。\n不应从低级模块导入任何内容！ 上图中的支付抽象定义在了支付模块，订单模块需要从支付模块导入。明显不符合规则！调整一下示意图：\n这样依赖抽象和反转就很明显的能看出来了 🙃。\n反转 是这一原则的精髓所在，订单模块和支付模块依赖关系对调了。从低级模块有什么，高阶模块就只能用什么，反转为由高阶模块提供信息，低级模块调用。\n这就好比食堂和下馆子的区别。去食堂吃饭，食堂当天炒了什么菜你就只能吃什么。下馆子则不同，想吃啥先下单（提供菜品信息），厨房拿到订单直接给你做。显然下馆子吃的更舒服，更能适应变化。\n具体实现 回到订单支付流程，现在看产品订单需要提供哪些信息。\n订单金额、订单号 验证订单流 完成订单的回调 抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // pending-order.ts import { Observable } from \u0026#39;rxjs\u0026#39; export abstract class PendingOrder { /** 支付金额 */ abstract get payAmount(): number /** 订单号 */ abstract get orderNo(): string /**支付前验证*/ abstract beforePay(): Observable\u0026lt;void\u0026gt; /** 支付完成 */ abstract payCompleted(): void } 订单实现取决于抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // flight-order.component.ts import { Component, forwardRef, OnInit } from \u0026#39;@angular/core\u0026#39; import { of } from \u0026#39;rxjs\u0026#39; import { tap } from \u0026#39;rxjs/operators\u0026#39; import { PendingOrder } from \u0026#39;../common/pending-order\u0026#39; @Component({ selector: \u0026#39;app-flight-order\u0026#39;, templateUrl: \u0026#39;./flight-order.component.html\u0026#39;, styleUrls: [\u0026#39;./flight-order.component.css\u0026#39;], providers: [ { provide: PendingOrder, useExisting: forwardRef(() =\u0026gt; FlightOrderComponent), }, ], }) export class FlightOrderComponent extends PendingOrder implements OnInit { constructor() { super() } ngOnInit() {} payCompleted() { console.log(\u0026#39;flight order pay completed\u0026#39;) } beforePay() { return of(null).pipe(tap(() =\u0026gt; console.log(\u0026#39;flight order before pay\u0026#39;))) } get payAmount() { return 9999 } get orderNo() { return \u0026#39;flight order no:fffffffffffffffffffffff\u0026#39; } } 支付模块依赖于订单模块的抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39; import { PendingOrder } from \u0026#39;../../common/pending-order\u0026#39; @Component({ selector: \u0026#39;app-balance-pay\u0026#39;, templateUrl: \u0026#39;./balance-pay.component.html\u0026#39;, styleUrls: [\u0026#39;./balance-pay.component.css\u0026#39;], }) export class BalancePayComponent implements OnInit { constructor(public order: PendingOrder) {} ngOnInit() {} handlePay() { console.log(\u0026#39;balance pay\u0026#39;) this.order .beforePay() .pipe() .subscribe((_) =\u0026gt; { this.order.payCompleted() }) } } 演示 demo：https://stackblitz.com/edit/angular-f7cueh，切换订单/支付按钮，点击“支付”查看控制台输出\n总结 撸完支付组件，感觉依赖反转原则（Dependence Inversion Principle）应用起来真是太妙了。订单页和支付组件解耦了不说，订单页还拥有了主动权，扩展性嗷嗷的。产品需求尽管加尽管变，小爷轻松给你实现 😎\n","description":"","id":2,"section":"posts","tags":null,"title":"Angular 依赖注入重写支付组件","uri":"https://sssylvan.github.io/posts/angular-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E7%BB%84%E4%BB%B6/"},{"content":" HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 HTTP 旨在尽可能多地缓存，面对缓存这道难题，在项目上线前缓存策略是必须考虑和配置好的：\n一次性资源，设置尽可能大的 max-age 会变更资源，设置 no-cache 能确定时效，设置 Expires、must-revalidate，注意与 max-age 的冲突 此外，在配置 Web 服务器消息头时，还有 🛡️ 安全相关 的设置需要注意： https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":3,"section":"posts","tags":null,"title":"HTTP 缓存实践总结","uri":"https://sssylvan.github.io/posts/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":" Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用 hugo 生成静态博客并部署在 GitHub 上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":4,"section":"posts","tags":null,"title":"Hugo + Github Pages 搭建个人博客","uri":"https://sssylvan.github.io/posts/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"content":" 最近看到了两位大佬天花板级别的类型体操：\n用 TypeScript 类型运算实现一个中国象棋程序 - 徐飞 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器 - brambles 看完只能献上我的 🧎‍♂️。网上也出现一些 type-challenges 上的面试骚题，大部分是考察 infer 的应用。\n实际项目中，抽象不同业务的相同流程时，我有使用 infer 推断具体业务类型。infer 的强大在于可以通过模式匹配可以从泛型中提取到类型，总结有 4 种场景：\n对象属性类型 函数参数类型和返回值类型 Function Parameters and Return type 数组 Array 模板字符串 Template Literals 使用前注意：infer 只能出现 extends 条件类型1 语句中，且类型变量只能在 true 分支中使用。\n条件类型语法有点像 JavaScript 的三元运算 (condition ? trueExpression : falseExpression) ：\n1 SomeType extends OtherType ? TrueType : FalseType; 对象属性 condition 的写法是属性作为 key，值使用 infer ：{ prop : infer V }。下面代码从通用的接口类型中获取 todo 数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 interface ApiResponse\u0026lt;T\u0026gt; { code: number data: T } interface Todo { content: string completed: boolean } type TodosResp = ApiResponse\u0026lt;Todo[]\u0026gt; type GetRespData\u0026lt;T\u0026gt; = T extends { data: infer V } ? V : never type DataInTodoResp = GetRespData\u0026lt;TodosResp\u0026gt; // Todo[] 函数参数和返回值 写出函数类型声明 (...args: any[]) =\u0026gt; any 然后填空即可\n返回值类型\n1 type MyReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : never 参数类型\n1 2 3 4 5 type MyParameters\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...any: infer P ) =\u0026gt; any ? P : never 数组 一类仍然是模式匹配，通过解构赋值2，取数组第一个/最后一个的类型\n1 2 type First\u0026lt;T extends any[]\u0026gt; = T extends [infer F, ...any[]] ? F : never type Last\u0026lt;T extends any[]\u0026gt; = T extends [...any[], infer L] ? L : never 一类要使用递归，在类型系统中实现 JavaScript Array.includes 函数，解构取到第一个元素和由剩余元素组成的数组，第一个匹配成功返回 true，未匹配成功继续用剩下的数组匹配。\ntype Includes\u0026lt;T extends readonly any[], U\u0026gt; = T extends [infer F,...infer R] ? (Equal\u0026lt;F,U\u0026gt; extends true ? true : Includes\u0026lt;R,U\u0026gt;) : false 模板字符串 删除两段的空白字符串 Trim，解法是模板模式配合递归\n1 2 3 4 5 6 type Chars = \u0026#39; \u0026#39; | \u0026#39;\\n\u0026#39; | \u0026#39;\\t\u0026#39; type Trim\u0026lt;S extends string\u0026gt; = S extends `${Chars}${infer SS}` ? Trim\u0026lt;SS\u0026gt; : S extends `${infer SS}${Chars}` ? Trim\u0026lt;SS\u0026gt; : S 总结 4 个场景捋下来，使用 infer 提取类型的关键在于写出符合不同数据结构的模式，然后填空即可。日常业务开发，这些袋鼠摇基本够用了~ 🦘\nhttps://www.typescriptlang.org/docs/handbook/2/conditional-types.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":5,"section":"posts","tags":null,"title":"Typescript 使用 infer 的4种场景","uri":"https://sssylvan.github.io/posts/typescript-%E4%BD%BF%E7%94%A8-infer-%E7%9A%844%E7%A7%8D%E5%9C%BA%E6%99%AF/"},{"content":" 在 Javascript 中，undefined 和 null 是若即若离的空值两兄弟 🧑‍🤝‍🧑（nullish value1）。我们有时候把它们视为两个不同的概念，有时候又把它们作相同的处理。\n概念不同 从数据角度讲，两者完全是两个概念：\nundefined 表示值不存在。内存空间找不到变量对应的值 null 则是一个字面量“空”。变量指向内存里表示“空”的地址 下面这张图能直观看到两者的差异：\n2\n给函数参数的设置默认值只对 undefined 生效\n1 2 3 4 5 6 7 function test(num = 1) { console.log(typeof num) } test() // \u0026#39;number\u0026#39; (num is set to 1) test(undefined) // \u0026#39;number\u0026#39; (num is set to 1 too) test(null) // \u0026#39;object\u0026#39; (num is set to null) 实际业务中也有区分的场景，比如表单有一数值项，用户不输入和输入后清空，页面显示该项都为空，但是前者表示用户没有任何操作，后者则表示用户填写值是 null。\nNullish 家族 一般情况下， ==（The Abstract Equality Comparison Algorithm 3）在比较前将两个被比较的值转换为相同类型。但 null == undefined 是特例，它俩的抽象相等比较的结果是 true。\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:\nIf x is null and y is undefined, return true. If x is undefined and y is null, return true. 两兄弟认祖归宗 Nullish 家族 👨‍❤️‍💋‍👨。Nullish 家族目前有 3 个技能：空值合并操作符 ??（Nullish coalescing operator4）、空值合并赋值 ??=（Nullish coalescing assignment）、可选链 (?.)（Optional chaining）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Nullish coalescing operator const foo = null ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; const boo = undefined ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; // Nullish coalescing assignment const a = { duration: null } a.duration ??= 10 a.speed ??= 25 a // {duration: 10, speed: 25} // Optional chaining const greet = null greet?.() // undefined const sing = undefined sing?.() // undefined 把它们放到一个家族里，个人感觉是为了精简啰嗦的判断语法，Nullish 家族的技能都可用其它方式实现。但因为实际业务中它俩同时出现的频率实在太高，索性整合到一起。\n比如表单有一数值项和根据该数值计算得到的结果。数值是 null 和 undefined 时可能不显示结果。\nundefined 的历史 以下内容截取至 undefined 与 null 的区别 - 阮一峰\n1995 年JavaScript 诞生之初像 Java 一样，只设置了 null 作为表示\u0026quot;无\u0026quot;的值。\n根据 C 语言的传统，null 被设计成可以自动转为 0。\n1 2 Number(null) // 0 5 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。\n首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示\u0026quot;无\u0026quot;的值最好不是对象。\n其次，JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。\n因此，Brendan Eich 又设计了一个 undefined。\nJavascript 设计之初是运行在客户端的动态解释型语言，对数据没有约束力，所以也需要有不存在这一概念。\n有点奇怪的 null 奇怪的类型，null 是原始类型（primitive ）中的一员，但 typeof null 的结果是 object。嘿，这其实是大佬留下的一坨 💩5。JavaScript 值包含类型标记和值。 000 表示对象类型，而 null 刚好是 32 个 0 。\n不行，这坨我吃不下。一定要拿到 null 类型（当然也可以用 === strict equality）\n1 Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; 奇怪的数值转换，这是只能吃的一坨~ 6\n1 2 Number(null) // 0 null == 0 // false 原型链的的终点是 null 7\n1 Object.prototype.__proto__ // null 总结 undefined 和 null 从数据角度看，有本质的不同：null 是空值，undefined 是不存在。如果业务上需要明确区分，在提交数据时应该注意。而在客户端消费数据时，两个都是 无效值，可以使用 Nullish 家族技能，用更简洁的语法实现需求。\nhttps://developer.mozilla.org/en-US/docs/Glossary/Nullish\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-11.9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://2ality.com/2013/10/typeof-null.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/ecma262/#sec-properties-of-the-object-prototype-object\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":6,"section":"posts","tags":null,"title":"undefined 和 null  那些事","uri":"https://sssylvan.github.io/posts/undefined-%E5%92%8C-null-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]