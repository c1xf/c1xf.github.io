[{"content":"面向对象编程的利弊 1\n","description":"","id":0,"section":"others","tags":null,"title":"","uri":"https://sssylvan.github.io/others/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%88%A9%E5%BC%8A/"},{"content":"React 基础 React 核心理念是状态驱动视图 Fn(State) =\u0026gt; UI，这在 Class 组件年代的开发体验并不明显，直到颠覆性的创新 Hooks 出现。Hooks 带来了完全函数式的编程体验，让代码不再从 UI 视角来编写（比如在组件挂载，卸载的生命周期应该做哪些事情），变为围绕业务状态来组织。\n用 React 社区的一张图直观地展现了对比结果，图的左侧是 Class 组件，右侧是 Function 组件结合 Hooks，蓝色和黄色代表不同的业务功能：\n可以看到在函数组件中，不同的业务逻辑之间代码是完全分开的，可读性可维护性都比左边的 Class 组件要高。假如黄色代码块是新增的业务，在做 code review 时就不需要查看不相关的代码；某天另一个组件可以也有黄色块的需求，也可以很快的将其抽出去实现复用。\n细看代码，函数组件没有生命周期，取而代之的是用 useEffect 声明副作用。这是由命令式到声明式的转变，生命周期变成了“底层概念”，开发者写好“声明”，具体如何执行交给 React。\nFunction 组件带来的全是优点吗？继续看两边的代码，函数组件就像是 Class 组件把属性方法都扔到 render 方法里面。而 render 方法可能会执行多次，然后通过 Diff 算法决定更新哪些 DOM 节点，这让开发者有了性能负担。比如下面代码中每次 Counter 函数执行，都会新建 handleIncrease 函数，Diff 结果是 button 需要更新，这并非开发者本意。在 Class 组件中事件绑定的是 this 里面的方法，也就没有这个问题。\n1 2 3 4 5 6 7 export default function Counter(props){ const [count,setCount] = useState(0) const handleIncrease = ()=\u0026gt;{ setCount(count+1) } return (\u0026lt;div\u0026gt;{count}\u0026lt;button onClick=\u0026#34;{handleIncrease}\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;) } Function 组件让代码更简洁、易复用，但也蕴含了性能陷阱。想要用好它必须打好基础，对 React 的更新渲染机制，Hooks 实现原理有一定的了解。\nReact 渲染流程 React 使用单向数据流 + 虚拟DOM（Virtual DOM）实现 UI 更新， 其过程可以简单理解为：\n组件的 Props 或 State 发生变化时，会触发组件更新 组件更新时，React 会构建一个新的虚拟 DOM 树，用于表示最新的组件结构 比较新旧结构，找到差异部分，生成一份差异列表 根据差异列表，React 对页面上的真实 DOM 进行更新 从流程上可以得出一个简单的结论：State 触发更新的范围越小性能越好。我们开发时，应该尽可能拆分组件下放 State，避免触发不必要的更新。此外不同于 Vue 可以基于模板做静态优化，减少不必要的 Diff，React 没有静态部分，它的 JSX 标记只是 React.createElement 的语法糖。所以开发时还应该注意动态部分和静态部分的拆分。\nHooks 实现原理 纯函数只能进行数据计算，并没有一个对象实例在多次执行之间保存状态。Hook 一种特殊的函数，它为函数组件“钩入”状态和生命周期等副作用（side effect），把外部的状态绑定到函数组件的执行。当状态变化时，函数组件能自动重新执行。\n","description":"","id":1,"section":"react","tags":null,"title":"","uri":"https://sssylvan.github.io/react/react-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"},{"content":"当日事当日毕 用书写沉淀知识，记录规律\n学习策略 对知识进行分类，制定不同的学习方式方法，提升学习效率\n知识分类 日常工作生活中，知识一般分为两类：工具类、经验类\n工具类知识 工具类知识特点分析：\n工具类知识直接影响效率 工具类知识比较容易上手，查阅文档即可 工具类知识随着工具的版本更新 工具类知识只对当前使用的工具有效，更换工具，知识可能就会失效 以写代码为例：一般的文本编辑器和 vscode 都能写代码。但掌握 vscode 开发效率会明显提升。可是如果哪天出现效率更高的 IDE 可以替换掉 vscode，你掌握的技巧（如：各种快捷键 F1, Ctrl+R）在新工具上可能就失灵了（ps：新 IDE 产品一般会考虑用户的迁移成本）\n直接影响效率，工具类知识很重要，但因为时效性的限制，它的重要性具备一定的迷惑性，容易让人沉迷在工具的使用上\n学习策略 用 github issue 记录这类知识，方便更新，一周进行一次整理，在仓库中备份。\n针对常用的工具知识，进行有意识的训练形成肌肉记忆。例：快捷键、vim。\n不常用的工具知识，记录好场景和解决方案。例：git、shell 命令。\n英语归为此类。\n经验类知识 世上本没有路，走的人多了就有了路。\n人本没有经验，做得多了就有了经验。\n一个问题的解决方式往往会有很多种，经验让人找到最合适的一个。\n经验类知识再细分，可分为：\n实战应用型。如 Angular 的实战项目经验 通用理论型。如 SOLID 五大设计原则 总结策略 实战应用型，以演示 demo 的形式记录，辅以代码注释。 通用理论的个人理解，以 blog 的文字记录。 ","description":"","id":2,"section":"","tags":null,"title":"","uri":"https://sssylvan.github.io/readme/"},{"content":"待办事项 javascript null 和 undefined 那些事 date typescript 类型体操 vue 全局弹窗 点击事件节流 其他 axios token 刷新请求重发 ","description":"","id":3,"section":"","tags":null,"title":"","uri":"https://sssylvan.github.io/todos/"},{"content":"这是一些文字\n测试一下 github actions\n","description":"test post index","id":4,"section":"react","tags":null,"title":"Hooks","uri":"https://sssylvan.github.io/react/hooks/"},{"content":"HTTP 缓存实践总结 HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 HTTP 旨在尽可能多地缓存，面对缓存这道难题，在项目上线前缓存策略是必须考虑和配置好的：\n一次性资源，设置尽可能大的 max-age 会变更资源，设置 no-cache 能确定时效，设置 Expires、must-revalidate，注意与 max-age 的冲突 此外，在配置 Web 服务器消息头时，还有🛡️ 安全相关 的设置需要注意： https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":5,"section":"others","tags":null,"title":"HTTP 缓存实践总结","uri":"https://sssylvan.github.io/others/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":"Hugo + Github Pages 搭建个人博客 Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用hugo生成静态博客并部署在GitHub上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":6,"section":"others","tags":null,"title":"Hugo + Github Pages 搭建个人博客","uri":"https://sssylvan.github.io/others/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"content":"🧑‍🤝‍🧑 undefined 和 null 那些事 在 Javascript 中，undefined 和 null 是若即若离的空值两兄弟 🧑‍🤝‍🧑（nullish value1）。我们有时候把它们视为两个不同的概念，有时候又把它们作相同的处理。\n概念不同 从数据角度讲，两者完全是两个概念：\nundefined 表示值不存在。内存空间找不到变量对应的值 null 则是一个字面量“空”。变量指向内存里表示“空”的地址 下面这张图能直观看到两者的差异：\n2\n给函数参数的设置默认值只对 undefined 生效\n1 2 3 4 5 6 7 function test(num = 1) { console.log(typeof num); } test(); // \u0026#39;number\u0026#39; (num is set to 1) test(undefined); // \u0026#39;number\u0026#39; (num is set to 1 too) test(null); // \u0026#39;object\u0026#39; (num is set to null) 实际业务中也有区分的场景，比如表单有一数值项，用户不输入和输入后清空，页面显示该项都为空，但是前者表示用户没有任何操作，后者则表示用户填写值是 null。\nNullish 家族 一般情况下， ==（The Abstract Equality Comparison Algorithm 3）在比较前将两个被比较的值转换为相同类型。但 null == undefined 是特例，它俩的抽象相等比较的结果是 true。\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:\nIf x is null and y is undefined, return true. If x is undefined and y is null, return true. 两兄弟认祖归宗 Nullish 家族 👨‍❤️‍💋‍👨。Nullish 家族目前有3个技能：空值合并操作符 ??（Nullish coalescing operator4）、空值合并赋值 ??=（Nullish coalescing assignment）、可选链 (?.)（Optional chaining）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Nullish coalescing operator const foo = null ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; const boo= undefined ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; // Nullish coalescing assignment const a = {duration:null} a.duration ??= 10 a.speed ??= 25 a // {duration: 10, speed: 25} // Optional chaining const greet = null greet?.() // undefined const sing = undefined sing?.() // undefined 把它们放到一个家族里，个人感觉是为了精简啰嗦的判断语法，Nullish 家族的技能都可用其它方式实现。但因为实际业务中它俩同时出现的频率实在太高，索性整合到一起。\n比如表单有一数值项和根据该数值计算得到的结果。数值是 null 和 undefined 时可能不显示结果。\nundefined 的历史 以下内容截取至 undefined与null的区别 - 阮一峰\n1995年JavaScript诞生之初像 Java 一样，只设置了 null 作为表示\u0026quot;无\u0026quot;的值。\n根据C语言的传统，null 被设计成可以自动转为 0。\n1 2 Number(null) // 0 5 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。\n首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示\u0026quot;无\u0026quot;的值最好不是对象。\n其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果 null 自动转为 0，很不容易发现错误。\n因此，Brendan Eich又设计了一个 undefined。\nJavascript 设计之初是运行在客户端的动态解释型语言，对数据没有约束力，所以也需要有不存在这一概念。\n有点奇怪的 null 奇怪的类型，null 是原始类型（primitive ）中的一员，但 typeof null 的结果是 object。嘿，这其实是大佬留下的一坨 💩5。JavaScript 值包含类型标记和值。 000 表示对象类型，而 null 刚好是 32个 0 。\n不行，这坨我吃不下。一定要拿到 null 类型（当然也可以用 === strict equality）\n1 Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; 奇怪的数值转换，这是只能吃的一坨~ 6\n1 2 Number(null) // 0 null == 0 // false 原型链的的终点是 null 7\n1 Object.prototype.__proto__ // null 总结 undefined 和 null 从数据角度看，有本质的不同：null 是空值，undefined 是不存在。如果业务上需要明确区分，在提交数据时应该注意。而在客户端消费数据时，两个都是 无效值，可以使用 Nullish 家族技能，用更简洁的语法实现需求。\nhttps://developer.mozilla.org/en-US/docs/Glossary/Nullish\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-11.9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://2ality.com/2013/10/typeof-null.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/ecma262/#sec-properties-of-the-object-prototype-object\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":7,"section":"javascript","tags":null,"title":"undefined 和 null  那些事","uri":"https://sssylvan.github.io/javascript/undefined-%E5%92%8C-null-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]