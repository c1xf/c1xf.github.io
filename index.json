[{"content":"React 基础 React 核心理念是状态驱动视图 Fn(State) =\u0026gt; UI，这在 Class 组件年代的开发体验并不明显，直到颠覆性的创新 Hooks 出现。Hooks 带来了完全函数式的编程体验，让代码不再从 UI 视角来编写（比如在组件挂载，卸载的生命周期应该做哪些事情），变为围绕业务状态来组织。\n用 React 社区的一张图直观地展现了对比结果，图的左侧是 Class 组件，右侧是 Function 组件结合 Hooks，蓝色和黄色代表不同的业务功能：\n可以看到在函数组件中，不同的业务逻辑之间代码是完全分开的，可读性可维护性都比左边的 Class 组件要高。假如黄色代码块是新增的业务，在做 code review 时就不需要查看不相关的代码；某天另一个组件可以也有黄色块的需求，也可以很快的将其抽出去实现复用。\n细看代码，函数组件没有生命周期，取而代之的是用 useEffect 声明副作用。这是由命令式到声明式的转变，生命周期变成了“底层概念”，开发者写好“声明”，具体如何执行交给 React。\nFunction 组件带来的全是优点吗？继续看两边的代码，函数组件就像是 Class 组件把属性方法都扔到 render 方法里面。而 render 方法可能会执行多次，然后通过 Diff 算法决定更新哪些 DOM 节点，这让开发者有了性能负担。比如下面代码中每次 Counter 函数执行，都会新建 handleIncrease 函数，Diff 结果是 button 需要更新，这并非开发者本意。在 Class 组件中事件绑定的是 this 里面的方法，也就没有这个问题。\n1 2 3 4 5 6 7 export default function Counter(props){ const [count,setCount] = useState(0) const handleIncrease = ()=\u0026gt;{ setCount(count+1) } return (\u0026lt;div\u0026gt;{count}\u0026lt;button onClick=\u0026#34;{handleIncrease}\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;) } Function 组件让代码更简洁、易复用，但也蕴含了性能陷阱。想要用好它必须打好基础，对 React 的更新渲染机制，Hooks 实现原理有一定的了解。\nReact 渲染流程 React 使用单向数据流 + 虚拟DOM（Virtual DOM）实现 UI 更新， 其过程可以简单理解为：\n组件的 Props 或 State 发生变化时，会触发组件更新 组件更新时，React 会构建一个新的虚拟 DOM 树，用于表示最新的组件结构 比较新旧结构，找到差异部分，生成一份差异列表 根据差异列表，React 对页面上的真实 DOM 进行更新 从流程上可以得出一个简单的结论：State 触发更新的范围越小性能越好。我们开发时，应该尽可能拆分组件下放 State，避免触发不必要的更新。此外不同于 Vue 可以基于模板做静态优化，减少不必要的 Diff，React 没有静态部分，它的 JSX 标记只是 React.createElement 的语法糖。所以开发时还应该注意动态部分和静态部分的拆分。\nHooks 实现原理 纯函数只能进行数据计算，并没有一个对象实例在多次执行之间保存状态。Hook 一种特殊的函数，它为函数组件“钩入”状态和生命周期等副作用（side effect），把外部的状态绑定到函数组件的执行。当状态变化时，函数组件能自动重新执行。\n","description":"","id":0,"section":"react","tags":null,"title":"","uri":"https://sssylvan.github.io/react/react-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"},{"content":"这是一些文字\n测试一下 github actions\n","description":"test post index","id":1,"section":"react","tags":null,"title":"Hooks","uri":"https://sssylvan.github.io/react/hooks/"},{"content":"HTTP 缓存实践总结 HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 由于 HTTP 旨在尽可能多地缓存，在项目上线前缓存策略是必须考虑和配置好的。同时 HTTP 版本不断向前迭代，网上的资料可能已经过期，多实践避免踩坑。\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":2,"section":"others","tags":null,"title":"HTTP 缓存实践总结","uri":"https://sssylvan.github.io/others/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":"Hugo + Github Pages 搭建个人博客 Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用 hugo 生成静态博客并部署在 GitHub 上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":3,"section":"others","tags":null,"title":"Hugo + Github Pages 搭建个人博客","uri":"https://sssylvan.github.io/others/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]