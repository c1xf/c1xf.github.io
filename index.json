[{"content":"https://www.typescriptlang.org/docs/handbook/2/keyof-types.html\n除了提取类型，筛选类型的场景也比较多，以 Omit 为例，把要过滤掉的 key 转为 never\n1 type MyOmit\u0026lt;T, K extends keyof T\u0026gt; = {[P in keyof T as P extends K ? never: P] :T[P]} keyof [^3] [^3]: https://www.typescriptlang.org/docs/handbook/2/keyof-types.html\nhttps://no1.engineer/articles/2021-03/covariance-and-contravariance\n大白话聊 TypeScript 中的变型 28 MAR 2021 • 6 mins read\n之前遇到一道 type-challenge ，在 TypeScript 中将一个联合类型转成交叉类型：\ntype UnionToIntersection\u0026lt;U\u0026gt; = any /* _____________ Test Cases _____________ */ import { Equal, Expect } from \u0026#39;@type-challenges/utils\u0026#39; type cases = [ Expect\u0026lt;Equal\u0026lt;UnionToIntersection\u0026lt;\u0026#39;foo\u0026#39; | 42 | true\u0026gt;, \u0026#39;foo\u0026#39; \u0026amp; 42 \u0026amp; true\u0026gt;\u0026gt;, Expect\u0026lt;Equal\u0026lt;UnionToIntersection\u0026lt;(() =\u0026gt; \u0026#39;foo\u0026#39;) | ((i: 42) =\u0026gt; true)\u0026gt;, (() =\u0026gt; \u0026#39;foo\u0026#39;) \u0026amp; ((i: 42) =\u0026gt; true)\u0026gt;\u0026gt;, ] 乍一看无从下手，后来思索了半天只能翻看答案，不觉惊叹巧妙：\ntype UnionToIntersection\u0026lt;UnionType\u0026gt; = ( UnionType extends any ? (param: UnionType) =\u0026gt; any : never ) extends (param: infer IntersectionType) =\u0026gt; any ? IntersectionType : never 这里面巧妙的使用了 TypeScript 的类型推断、条件类型以及协变和逆变的知识，如果你能做出来的话，一定是非常熟悉 TypeScript 中协变和逆变的同学。\n如果看不懂也不要着急，接下来就来一起看一下为什么这么做。\n类型安全（Type Safety） 类型理论是非常复杂的理论。我们使用拥有类型系统的编程语言的时候，会接触到“类型安全”的概念。\n类型安全有很多种解释方法，我们先来解释一下与之相反的“类型不安全”是什么。你可以去维基百科上找一下定义比较复杂。\n大白话来讲，程序的本质就是不断求值，而当程序存在求出来的值可能不能明确类型的时候，使用的编程语言就是类型不安全的；反之即类型安全（Type Safety）。\n《Types and Programming Languages》 上有个公式用来描述什么是编程语言的类型安全：\nType Safety = Progress + Preservation\nProgress: A well-typed term is not stuck (either it is a value or it can take astep according to the evaluation rules).\nPreservation: If a well-typed term takes a step of evaluation, then the resulting term is also well typed.\n即：\n流程性：一个 well-typed 的程序项不会被卡住（或者已经是值，或者可以继续求值）； 保留性：一个 well-typed 的程序项经过N次求值后仍是 well-typed 的（特性可以无穷无尽的保留下去）； 变型 编程语言为了实现类型安全，就会设计一系列类型规则来保证。最常见的规则就是类型从一个变成另一个时的规则，这个叫做类型的｀变型｀。\n为了说明变型，我们来定义一些方便我们表达的标记：\n我们使用范畴论中两个范畴之间的标记来标示类型：\nSubType ≦ SuperType //　子类和父类的关系 我们假设类型变换规则为 F，\nF(SubType) ≦ F(SuperType)，我们称 F 这个规则是 协变 的； F(SuperType) ≦ F(SubType)，我们称 F 这个规则是 逆变 的； 除此之外还有不变、非协变非逆变，这里就不讨论了。\nTypeScript中协变与逆变（Covariance \u0026amp; Contravariance） TypeScript 变量类型是满足协变的，所以我们才可以使用 SubType 替代 SuperType ：\ninterface SuperType { superTypeProp: number } interface SubType extends SuperType { subTypeProp: number } type ResultType = SubType extends SuperType ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; 因为 SubType 是继承了 SuperType 的子类，按照 TypeScript 中类型安全的规则，SubType 的实例可以替代 SuperType 的实例求值：\nconst subTypeInstance: SubType = new SubType() const needSuperTypeInstance: SuperType = subTypeInstance 反之，SuperType 的实例不可以替代 SubType 的实例求值：\nconst superTypeInstance: SuperType = new SuperType() const needSubTypeInstance: SubType = superTypeInstance // Compiler Error TypeScript 中 Tuple 类型满足协变，所以：\ninterface SuperType { superTypeProp: number } interface SubType extends SuperType { subTypeProp: number } type SuperTypeTuple = [SuperType, SuperType] type SubTypeTuple = [SubType, SuperType] type ResultType = SubTypeTuple extends SuperTypeTuple ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; 但是子类型数量不同是不满足的，所以：\ninterface SuperType { superTypeProp: number } interface SubType extends SuperType { subTypeProp: number } type SuperTypeTuple = [SuperType, SuperType] type SubTypeTuple = [SubType, SubType, SubType] type ResultType = SubTypeTuple extends SuperTypeTuple ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;no\u0026#39; List 也是满足协变的：\ninterface SuperType { superTypeProp: number } interface SubType extends SuperType { subTypeProp: number } type SuperTypeList = SuperType[] type SubTypeList = SubType[] type ResultType = SubTypeList extends SuperTypeList ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; Function 是逆变的：\ninterface SuperType { superTypeProp: number } interface SubType extends SuperType { subTypeProp: number } type SuperTypeParamFunction = (param: SuperType) =\u0026gt; any type SubTypeParamFunction = (param: SubType) =\u0026gt; any type SuperTypeReturnsFunction = (param: any) =\u0026gt; SuperType type SubTypeReturnsFunction = (param: any) =\u0026gt; SubType type SuperTypeParamAndSubTypeReturnsFunction = (param: SuperType) =\u0026gt; SubType type SubTypeParamAndSuperTypeReturnsFunction = (param: SubType) =\u0026gt; SuperType type ParamResultType = SuperTypeParamFunction extends SubTypeParamFunction ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; type ReturnsResultType = SubTypeReturnsFunction extends SuperTypeReturnsFunction ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; type ParamAndReturnsResultType = SuperTypeParamAndSubTypeReturnsFunction extends SubTypeParamAndSuperTypeReturnsFunction ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; // \u0026#39;yes\u0026#39; 事实上，(param: SuperType) =\u0026gt; any 是 (param: SubType) =\u0026gt; any 的子类，注意不要局限于参数的类型，因为 (param: SuperType) =\u0026gt; any 的实例可以替代 (param: SubType) =\u0026gt; any　的实例进行计算，这是类型安全的！\nSuperTypeParamFunction extends SubTypeParamFunction\n题目的解释 我们再回头来看题目。\n我们首先通过 条件类型 将 UnionType 变成 (param: UnionType) =\u0026gt; any 的形式，这步没有什么好说的；\n\u0026#39;foo\u0026#39; | 42 | true -\u0026gt; ((param: \u0026#39;foo\u0026#39;) =\u0026gt; any) | ((param: 42) =\u0026gt; any) | ((param: true) =\u0026gt; any) 然后通过 类型推导 来获取 (param: UnionType) =\u0026gt; any 的参数类型。按照上一节 TypeScript中协变与逆变 我们会发现：\n(param: \u0026#39;foo\u0026#39;) =\u0026gt; any ≦ (param: \u0026#39;foo\u0026#39; \u0026amp; 42 \u0026amp; true) =\u0026gt; any (param: 42) =\u0026gt; any ≦ (param: \u0026#39;foo\u0026#39; \u0026amp; 42 \u0026amp; true) =\u0026gt; any (param: true) =\u0026gt; any ≦ (param: \u0026#39;foo\u0026#39; \u0026amp; 42 \u0026amp; true) =\u0026gt; any 所以类型推导结果就是： (param: 'foo' \u0026amp; 42 \u0026amp; true) =\u0026gt; any：\ntype UnionToIntersection\u0026lt;UnionType\u0026gt; = ( UnionType extends any ? (param: UnionType) =\u0026gt; any : never ) extends (param: infer IntersectionType) =\u0026gt; any ? IntersectionType : never What’s more? 留个课后题，既然我们把 Union Type 转换成了 Intersection Type，那么，我们可以把 Intersection Type 转换成相应的 Union Type 吗？\n如果可以的话，怎么转呢？如果不可以的话，为什么呢？\n","description":"","id":0,"section":"javascript","tags":null,"title":"","uri":"https://sssylvan.github.io/javascript/typescript-omit-%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"},{"content":"面向对象编程的利弊 1\n","description":"","id":1,"section":"others","tags":null,"title":"","uri":"https://sssylvan.github.io/others/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%88%A9%E5%BC%8A/"},{"content":"React 基础 React 核心理念是状态驱动视图 Fn(State) =\u0026gt; UI，这在 Class 组件年代的开发体验并不明显，直到颠覆性的创新 Hooks 出现。Hooks 带来了完全函数式的编程体验，让代码不再从 UI 视角来编写（比如在组件挂载，卸载的生命周期应该做哪些事情），变为围绕业务状态来组织。\n用 React 社区的一张图直观地展现了对比结果，图的左侧是 Class 组件，右侧是 Function 组件结合 Hooks，蓝色和黄色代表不同的业务功能：\n可以看到在函数组件中，不同的业务逻辑之间代码是完全分开的，可读性可维护性都比左边的 Class 组件要高。假如黄色代码块是新增的业务，在做 code review 时就不需要查看不相关的代码；某天另一个组件可以也有黄色块的需求，也可以很快的将其抽出去实现复用。\n细看代码，函数组件没有生命周期，取而代之的是用 useEffect 声明副作用。这是由命令式到声明式的转变，生命周期变成了“底层概念”，开发者写好“声明”，具体如何执行交给 React。\nFunction 组件带来的全是优点吗？继续看两边的代码，函数组件就像是 Class 组件把属性方法都扔到 render 方法里面。而 render 方法可能会执行多次，然后通过 Diff 算法决定更新哪些 DOM 节点，这让开发者有了性能负担。比如下面代码中每次 Counter 函数执行，都会新建 handleIncrease 函数，Diff 结果是 button 需要更新，这并非开发者本意。在 Class 组件中事件绑定的是 this 里面的方法，也就没有这个问题。\n1 2 3 4 5 6 7 export default function Counter(props){ const [count,setCount] = useState(0) const handleIncrease = ()=\u0026gt;{ setCount(count+1) } return (\u0026lt;div\u0026gt;{count}\u0026lt;button onClick=\u0026#34;{handleIncrease}\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;) } Function 组件让代码更简洁、易复用，但也蕴含了性能陷阱。想要用好它必须打好基础，对 React 的更新渲染机制，Hooks 实现原理有一定的了解。\nReact 渲染流程 React 使用单向数据流 + 虚拟DOM（Virtual DOM）实现 UI 更新， 其过程可以简单理解为：\n组件的 Props 或 State 发生变化时，会触发组件更新 组件更新时，React 会构建一个新的虚拟 DOM 树，用于表示最新的组件结构 比较新旧结构，找到差异部分，生成一份差异列表 根据差异列表，React 对页面上的真实 DOM 进行更新 从流程上可以得出一个简单的结论：State 触发更新的范围越小性能越好。我们开发时，应该尽可能拆分组件下放 State，避免触发不必要的更新。此外不同于 Vue 可以基于模板做静态优化，减少不必要的 Diff，React 没有静态部分，它的 JSX 标记只是 React.createElement 的语法糖。所以开发时还应该注意动态部分和静态部分的拆分。\nHooks 实现原理 纯函数只能进行数据计算，并没有一个对象实例在多次执行之间保存状态。Hook 一种特殊的函数，它为函数组件“钩入”状态和生命周期等副作用（side effect），把外部的状态绑定到函数组件的执行。当状态变化时，函数组件能自动重新执行。\n","description":"","id":2,"section":"react","tags":null,"title":"","uri":"https://sssylvan.github.io/react/react-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"},{"content":"当日事当日毕 用书写沉淀知识，记录规律\n学习策略 对知识进行分类，制定不同的学习方式方法，提升学习效率\n知识分类 日常工作生活中，知识一般分为两类：工具类、经验类\n工具类知识 工具类知识特点分析：\n工具类知识直接影响效率 工具类知识比较容易上手，查阅文档即可 工具类知识随着工具的版本更新 工具类知识只对当前使用的工具有效，更换工具，知识可能就会失效 以写代码为例：一般的文本编辑器和 vscode 都能写代码。但掌握 vscode 开发效率会明显提升。可是如果哪天出现效率更高的 IDE 可以替换掉 vscode，你掌握的技巧（如：各种快捷键 F1, Ctrl+R）在新工具上可能就失灵了（ps：新 IDE 产品一般会考虑用户的迁移成本）\n直接影响效率，工具类知识很重要，但因为时效性的限制，它的重要性具备一定的迷惑性，容易让人沉迷在工具的使用上\n学习策略 用 github issue 记录这类知识，方便更新，一周进行一次整理，在仓库中备份。\n针对常用的工具知识，进行有意识的训练形成肌肉记忆。例：快捷键、vim。\n不常用的工具知识，记录好场景和解决方案。例：git、shell 命令。\n英语归为此类。\n经验类知识 世上本没有路，走的人多了就有了路。\n人本没有经验，做得多了就有了经验。\n一个问题的解决方式往往会有很多种，经验让人找到最合适的一个。\n经验类知识再细分，可分为：\n实战应用型。如 Angular 的实战项目经验 通用理论型。如 SOLID 五大设计原则 总结策略 实战应用型，以演示 demo 的形式记录，辅以代码注释。 通用理论的个人理解，以 blog 的文字记录。 ","description":"","id":3,"section":"","tags":null,"title":"","uri":"https://sssylvan.github.io/readme/"},{"content":"待办事项 javascript null 和 undefined 那些事 date typescript 类型体操 vue 全局弹窗 点击事件节流 其他 axios token 刷新请求重发 ","description":"","id":4,"section":"","tags":null,"title":"","uri":"https://sssylvan.github.io/todos/"},{"content":"这是一些文字\n测试一下 github actions\n","description":"test post index","id":5,"section":"react","tags":null,"title":"Hooks","uri":"https://sssylvan.github.io/react/hooks/"},{"content":"HTTP 缓存实践总结 HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 HTTP 旨在尽可能多地缓存，面对缓存这道难题，在项目上线前缓存策略是必须考虑和配置好的：\n一次性资源，设置尽可能大的 max-age 会变更资源，设置 no-cache 能确定时效，设置 Expires、must-revalidate，注意与 max-age 的冲突 此外，在配置 Web 服务器消息头时，还有🛡️ 安全相关 的设置需要注意： https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":6,"section":"others","tags":null,"title":"HTTP 缓存实践总结","uri":"https://sssylvan.github.io/others/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":"Hugo + Github Pages 搭建个人博客 Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用hugo生成静态博客并部署在GitHub上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":7,"section":"others","tags":null,"title":"Hugo + Github Pages 搭建个人博客","uri":"https://sssylvan.github.io/others/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"content":"Typescript 使用 infer 的 4 种场景 最近看到了两位大佬天花板级别的类型体操：\n用 TypeScript 类型运算实现一个中国象棋程序 - 徐飞 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器 - brambles 看完只能献上我的 🧎‍♂️。网上也出现一些 type-challenges 上的面试骚题，大部分是考察 infer 的应用。\n实际项目中，抽象不同业务的相同流程时，我有使用 infer 推断具体业务类型。infer 的强大在于可以通过模式匹配可以从泛型中提取到类型，总结有 4 种场景：\n对象属性类型 函数参数类型和返回值类型 Function Parameters and Return type 数组 Array 模板字符串 Template Literals 使用前注意：infer 只能出现 extends 条件类型1 语句中，且类型变量只能在 true 分支中使用。\n条件类型语法有点像 JavaScript 的三元运算 (condition ? trueExpression : falseExpression) ：\n1 SomeType extends OtherType ? TrueType : FalseType; 对象属性 condition 的写法是属性作为 key，值使用 infer ：{ prop : infer V }。下面代码从通用的接口类型中获取 todo 数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 interface ApiResponse\u0026lt;T\u0026gt; { code: number data: T } interface Todo { content: string completed: boolean } type TodosResp = ApiResponse\u0026lt;Todo[]\u0026gt; type GetRespData\u0026lt;T\u0026gt; = T extends { data: infer V } ? V : never type DataInTodoResp = GetRespData\u0026lt;TodosResp\u0026gt; // Todo[] 函数参数和返回值 写出函数类型声明 (...args: any[]) =\u0026gt; any 然后填空即可\n返回值类型\n1 type MyReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : never 参数类型\n1 2 3 4 5 type MyParameters\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...any: infer P ) =\u0026gt; any ? P : never 数组 一类仍然是模式匹配，通过解构赋值2，取数组第一个/最后一个的类型\n1 2 type First\u0026lt;T extends any[]\u0026gt; = T extends [infer F, ...any[]] ? F : never type Last\u0026lt;T extends any[]\u0026gt; = T extends [...any[], infer L] ? L : never 一类要使用递归，在类型系统中实现 JavaScript Array.includes 函数，解构取到第一个元素和由剩余元素组成的数组，第一个匹配成功返回 true，未匹配成功继续用剩下的数组匹配。\ntype Includes\u0026lt;T extends readonly any[], U\u0026gt; = T extends [infer F,...infer R] ? (Equal\u0026lt;F,U\u0026gt; extends true ? true : Includes\u0026lt;R,U\u0026gt;) : false 模板字符串 删除两段的空白字符串 Trim，解法是模板模式配合递归\n1 2 3 4 5 6 type Chars = \u0026#39; \u0026#39; | \u0026#39;\\n\u0026#39; | \u0026#39;\\t\u0026#39; type Trim\u0026lt;S extends string\u0026gt; = S extends `${Chars}${infer SS}` ? Trim\u0026lt;SS\u0026gt; : S extends `${infer SS}${Chars}` ? Trim\u0026lt;SS\u0026gt; : S 总结 4 个场景捋下来，使用 infer 提取类型的关键在于写出符合不同数据结构的模式，然后填空即可。日常业务开发，这些袋鼠摇基本够用了~ 🦘\nhttps://www.typescriptlang.org/docs/handbook/2/conditional-types.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":8,"section":"javascript","tags":null,"title":"Typescript 使用 infer 的4种场景","uri":"https://sssylvan.github.io/javascript/typescript-%E4%BD%BF%E7%94%A8-infer-%E7%9A%844%E7%A7%8D%E5%9C%BA%E6%99%AF/"},{"content":"🧑‍🤝‍🧑 undefined 和 null 那些事 在 Javascript 中，undefined 和 null 是若即若离的空值两兄弟 🧑‍🤝‍🧑（nullish value1）。我们有时候把它们视为两个不同的概念，有时候又把它们作相同的处理。\n概念不同 从数据角度讲，两者完全是两个概念：\nundefined 表示值不存在。内存空间找不到变量对应的值 null 则是一个字面量“空”。变量指向内存里表示“空”的地址 下面这张图能直观看到两者的差异：\n2\n给函数参数的设置默认值只对 undefined 生效\n1 2 3 4 5 6 7 function test(num = 1) { console.log(typeof num); } test(); // \u0026#39;number\u0026#39; (num is set to 1) test(undefined); // \u0026#39;number\u0026#39; (num is set to 1 too) test(null); // \u0026#39;object\u0026#39; (num is set to null) 实际业务中也有区分的场景，比如表单有一数值项，用户不输入和输入后清空，页面显示该项都为空，但是前者表示用户没有任何操作，后者则表示用户填写值是 null。\nNullish 家族 一般情况下， ==（The Abstract Equality Comparison Algorithm 3）在比较前将两个被比较的值转换为相同类型。但 null == undefined 是特例，它俩的抽象相等比较的结果是 true。\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:\nIf x is null and y is undefined, return true. If x is undefined and y is null, return true. 两兄弟认祖归宗 Nullish 家族 👨‍❤️‍💋‍👨。Nullish 家族目前有3个技能：空值合并操作符 ??（Nullish coalescing operator4）、空值合并赋值 ??=（Nullish coalescing assignment）、可选链 (?.)（Optional chaining）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Nullish coalescing operator const foo = null ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; const boo= undefined ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; // Nullish coalescing assignment const a = {duration:null} a.duration ??= 10 a.speed ??= 25 a // {duration: 10, speed: 25} // Optional chaining const greet = null greet?.() // undefined const sing = undefined sing?.() // undefined 把它们放到一个家族里，个人感觉是为了精简啰嗦的判断语法，Nullish 家族的技能都可用其它方式实现。但因为实际业务中它俩同时出现的频率实在太高，索性整合到一起。\n比如表单有一数值项和根据该数值计算得到的结果。数值是 null 和 undefined 时可能不显示结果。\nundefined 的历史 以下内容截取至 undefined与null的区别 - 阮一峰\n1995年JavaScript诞生之初像 Java 一样，只设置了 null 作为表示\u0026quot;无\u0026quot;的值。\n根据C语言的传统，null 被设计成可以自动转为 0。\n1 2 Number(null) // 0 5 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。\n首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示\u0026quot;无\u0026quot;的值最好不是对象。\n其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果 null 自动转为 0，很不容易发现错误。\n因此，Brendan Eich又设计了一个 undefined。\nJavascript 设计之初是运行在客户端的动态解释型语言，对数据没有约束力，所以也需要有不存在这一概念。\n有点奇怪的 null 奇怪的类型，null 是原始类型（primitive ）中的一员，但 typeof null 的结果是 object。嘿，这其实是大佬留下的一坨 💩5。JavaScript 值包含类型标记和值。 000 表示对象类型，而 null 刚好是 32个 0 。\n不行，这坨我吃不下。一定要拿到 null 类型（当然也可以用 === strict equality）\n1 Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; 奇怪的数值转换，这是只能吃的一坨~ 6\n1 2 Number(null) // 0 null == 0 // false 原型链的的终点是 null 7\n1 Object.prototype.__proto__ // null 总结 undefined 和 null 从数据角度看，有本质的不同：null 是空值，undefined 是不存在。如果业务上需要明确区分，在提交数据时应该注意。而在客户端消费数据时，两个都是 无效值，可以使用 Nullish 家族技能，用更简洁的语法实现需求。\nhttps://developer.mozilla.org/en-US/docs/Glossary/Nullish\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-11.9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://2ality.com/2013/10/typeof-null.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/ecma262/#sec-properties-of-the-object-prototype-object\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":9,"section":"javascript","tags":null,"title":"undefined 和 null  那些事","uri":"https://sssylvan.github.io/javascript/undefined-%E5%92%8C-null-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]