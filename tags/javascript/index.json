[{"content":"我从 14 年开始从事前端开发，刚好赶上了 MVVM 的时代浪潮。从 AvalonJS 🙏 开始，先后使用了 3 年多 Vue2，3 年多 Angular，断断续续有半年的 React。目前 Angular、React 仍是主力，正在将公司的前台业务从 Angular 迁移到 React，后台业务继续使用 Angular。这次迁移加上以往的开发经验，让我清晰感受到了三大框架的差异。(React 是 Library 称为 Framework 不太合适，为了描述方便，暂且统称为框架 ）\nAngular Anuglar 是让我受益最多的框架，是它带我入门 TypeScript，紧接着就被它完美的 Form 抽象所惊艳，而后被它基于 RxJS 打造的“海纳百川”刷新认知，最后被依赖注入的优雅所折服。\n作为当时刚从 Vue 转到 Angular 的我来讲，起初有被它的各种限制弄得不爽。慢慢发现它可以很好的解决了我在之前项目上碰到的头疼场景。\n比如，我实现过一个复杂的表单需求，产品的折扣力度要按区间设置，区间可以任意增删改，相连的区间不能有交集。复杂点在于动态的验证关系。虽然可以通过放弃一些用户体验，来降低复杂度，但在捋出验证流程后，还是用 Angular Form 比较轻松的实现了，没有牺牲用户体验。\n又比如我司的某个产品订单，提交订单这一流程上，有超多的判断节点。用户属性，购买记录，是否过期等等一连串的流程。不同用户有些流程需要跳过，有些又是中间有差异的两套判断，里面也是极其复杂。我的作法是把节点拆分清楚，每个节点只负责一种业务场景，最后用 RxJS 的流把这些节点串联起来。流程变得清晰直观。\n关于依赖注入，之前有写过一篇关于用它实现支付中心的博客，这里就不再啰嗦了，总之两个字：优雅 🍸。\n但是某些场景下，Augular 也经常会让我陷入纠结：这部分相同的代码该如何实现复用呢，Component、Service、Decorator 还是 Abstract Class？比如我司的订单下单页面。有多种用户角色：公务员、企业用户、个人用户。他们有部分功能通用，部分功能个性化，有时候部分通用功能还要改成个性化 😭。需求一变我的抽象立马变成超前设计，最后把复用这件事看得越来越慎重。。怎样作出能适应业务变化，符合开闭原则（Open–closed principle）的抽象一直困扰着我，还是功力不够吧~\n此外，因为 Angular 干了太多非原生的活，生产模式打出的包会比 Vue、React 大很多。\nVue2 Vue2 给我的感受简单、快。它和 Angular 一样开箱即用，且针对问题给出的解决方案是最简单直接的。比如组件跨层级的通讯，只需要在组件上添加 provide/inject 搞定。不需要扯出 Service 、Context 这些概念。它是可以让我快速出活的框架，而且拥有很好的性能。我只在早期写过一篇关于 Vue 源码的博客（太久远了加上牵扯的细节太多，没整理到这个站点），因为有什么问题，它的官网给安排得明明白白。两个字巴适：🏝️。\n我对 Vue2 使用还停留在几年前，这里不便过多评论。不过 template 在打包时一直没有类型检查，这让我有点不太放心的使用它。\n如果是 Vue2 + Typescript 开发的话，推荐使用 Vue Class Component 。Vue3 的 api 设计有点怪怪的，有点不好接受，一直没去尝试~\nReact React 有着最纯粹的哲学：UI = Fn(State)。被它吸引的原因，是 Hooks 可以让业务内聚更容易复用，解决使用 Angular 时抽象业务的纠结。当然也是因为 React 实在太火 🔥 了，反观 Angular 在国内已经逐渐势微。初次尝试后，感受到了 JSX 语法下 Function Component 行云流水般的舒适开发体验。但马上又感受到纯粹 != 简单，依赖闭包实现的 Hooks 让我早期踩了不少坑，甚至一度怀疑这算哪门子纯函数，后来了解到它是受到函数式编程代数效应的启发，便也念头通达了 🤯。\n紧接着 React 又抛给了我性能问题。由于 JSX 只是 createElement 的语法糖，React 没法像 Angular 、Vue 对静态模板做优化，跳过静态模板的检查。同时 React 的最小更新单位是组件，也做不到 Vue 的原子级更新。React 自身做不了，那谁来做呢？开发者啊 😩。开发者在编码时，要考虑把状态影响的范围尽可能缩小，避免状态变更触发昂贵的更新。（当然 React 也搞了 Fiber 做更新优化，厉害是非常厉害，但也有点擦屁股的嫌疑）。好在这样也不完全是问题，相反是对开发者一种挺好的约束 😏，避免了状态大乱炖。\n性能问题也导致社区很多表单解决方案是基于非受控组件，尽管官方推荐的是受控组件。非受控组件么得 React 的灵魂。我仍然会选择使用受控组件，无非是多写一点模板代码，一个状态对应一个组件。\nNo Silver Bullet 三大框架所展示的特质，又一次说明了没有银弹，只有平衡与取舍。没有一个框架可以完美通杀所有业务场景，只有针对业务特点，找到开发成本和维护性、扩展性的平衡点，继而找到合适的框架。斗胆简单总结下：Vue 适合业务不需要经常迭代的项目，又快又省心；Angular 适合有较多复杂表单的场景；React 则适合模块要组合多种功能的业务。\n以上是我对 Angular、Vue、React 的一点浅薄认知。欢迎评论留言交流 🥳。\n","description":"","id":0,"section":"posts","tags":["angular","vue","react"],"title":"Angular、Vue2、React 实战总结","uri":"https://c1xf.github.io/posts/angularvue2react-%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"},{"content":"与 Angular 的开箱即用不同，学完 React 官网的 Api 之后，手里只是有了把 AK-47 🔫。想要走上人生巅峰，赢取白富美 💃，还要挑选地图（路由），通讯设备（状态管理）等等方案。下面讲讲状态管理方案 Zustand 的实践经历。\n为什么引入状态管理 前端三大框架 React、Angular、Vue，状态传递都是自上而下，子组件之间的想要传递状态要通过父/祖先组件解决（提升 state），这可能会触发不必要的更新。场景如下：\nApp 分为 A、B 两个组件，A、B 组件又有各自的子组件。子组件 A1，B2 相互通讯，其他组件不受影响。\n为此 Angular 可以通过 Service 解决，Vue 有官方解决方案 Vuex，而 React 没有官方方案，因此催生了大量的社区方案：Redux、Zustand、Recoil、Mobx、Jotai 等等。\n为什么是 Zustand 在挑选解决方案时，首先看的自然是大名鼎鼎的 Redux，清晰的数据流、UI 框架无关性、配套开发工具。。但要写很多胶水代码粘合各个操作，另外怎么约束 type 命名，保证唯一性也是问题（有清楚的大佬，麻烦告知下 😙）。就我已知的，简单总结一下，Redux 虽然理念简单生态强，但写起来麻烦，且想要在项目上用起来，还得学习 Redux Toolkit 这些中间件。\n然后是朋友推荐的 Zustand （德文：状态）。Zustand 是基于 Hooks 实现的方案，比 Redux 更灵活更简单。提供多种状态管理风格，1.1k 超轻量，29k+ 的 star，极少的 issue，逐渐上升的下载量。根据我们项目的特点（从 Angular 迁移）：没有历史包袱，希望快速开发。Zustand 是比 Redux 更优的方案。\n1\nstore 的创建、调用和更新 先实现文章开头提出的需求：子组件传递状态。创建 store，按图示结构创建组件，并在每个函数组件中输出其组件名，其中 A1 组件 oneup 可以修改 B1 组件 count ，据此查看影响范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import { create } from \u0026#39;zustand\u0026#39; const useStore = create((set, get) =\u0026gt; ({ count: 0, actions: { inc: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count + 1 })), }, })) function A1() { console.log(\u0026#39;A1\u0026#39;) const actions = useStore((state) =\u0026gt; state.actions) return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;A1\u0026lt;/span\u0026gt; \u0026lt;button onClick={actions.inc}\u0026gt;one up\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function A2() { console.log(\u0026#39;A2\u0026#39;) return \u0026lt;div\u0026gt;A2\u0026lt;/div\u0026gt; } function B1() { console.log(\u0026#39;B1\u0026#39;) return \u0026lt;div\u0026gt;B1\u0026lt;/div\u0026gt; } function B2() { console.log(\u0026#39;B2\u0026#39;) const count = useStore((state) =\u0026gt; state.count) const actions = useStore((state) =\u0026gt; state.actions) return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;B2:{count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={actions.inc}\u0026gt;one up\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function A() { console.log(\u0026#39;A\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;A1 /\u0026gt; \u0026lt;A2 /\u0026gt; \u0026lt;/div\u0026gt; ) } function B() { console.log(\u0026#39;B\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;B1 /\u0026gt; \u0026lt;B2 /\u0026gt; \u0026lt;/div\u0026gt; ) } export default function App() { return ( \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;/div\u0026gt; ) } 首次渲染过后，点击 one up 按钮，控制台只会输出 B2。\n创建 store ：create((set,get)=\u0026gt;initialState) 。其中 set 更新 state，get 获取 state。\n状态获取 ：\n获取全部：const state = useStore() ❌。任一状态更改将更新组件，项目中不要使用。 按需获取（state slices）：const stateSlice = useStore(selector,equals?); ✔️。equals 默认为 old === new 严格相等。不建议为了少写几行代码使用 shallow。 getter 计算值\n错误方式 ❌：\n1 2 3 4 5 6 const useStore = create((set, get) =\u0026gt; ({ count: 1, get halfCount() { return get().count / 2 }, })) 正确方式 ✔️：\n1 2 3 4 5 6 7 8 const useStore = create((set, get) =\u0026gt; ({ count: 1, computed: { get halfCount() { return get().count / 2 }, }, })) 状态更新：\nset 默认为 合并 state set(state =\u0026gt; ({slice:newSlice}))，也可以禁用合并行为 set((state) =\u0026gt; newState, true)。\n更新操作，建议定义在 actions 内， 提升可读性，调用多个 action 是也更方便。\n推荐使用 ✔️：\n1 2 3 4 5 6 const useStore = create((set, get) =\u0026gt; ({ count: 0, actions: { inc: () =\u0026gt; useStore.setState((state) =\u0026gt; ({ count: state.count + 1 })), }, })) 组件级别 store Zustand 默认为全局状态。组件级别的状态（依赖注入）结合 React.context 实现。不会触发不必要的更新：\nInitialize state with props How to make a store instance per Component ? 未完待续\u0026hellip;\nIs Redux DEAD? Try Zustand!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":1,"section":"posts","tags":["react"],"title":"Zustand 实践总结","uri":"https://c1xf.github.io/posts/zustand-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":"初学 React Hooks 时，偶然在中文社区刷到一篇文章讲 “ React Hooks 的闭包陷阱” ，哇靠居然有坑，赶紧看 。看完自己也试了一下，运行结果确实反直觉。\n接下来一段时间，频繁在 React 相关的文章里看到 “闭包陷阱” 这个词。在聊天和写博客时，我也跟着用了起来。特别在写项目的时候，总想着不要踩到“陷阱”里，还给我造成了不小的心智压力。最近准备整理 React 的最佳实践，在思考 “闭包陷阱” 时，我发现这名词取得就是个坑！\n它讲得的是，useEffect 中的副作用函数只执行一次时，内部调用的 state 永远是初始值。这是由于 Hooks 的实现依赖闭包导致的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export default function App() { const [count, setCount] = useState(0) useEffect(function () { const timer = setInterval(function log() { console.log(`Count is: ${count}`) }, 2000) return () =\u0026gt; clearInterval(timer) }, []) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {count} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increase\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } setCount 不会更新 useEffect 里面 count。点击increase 按钮，页面显示的 {count} 会增加，而控制台每隔 2 秒输出的还是 Count is: 0 。\n对于熟悉闭包的开发者来讲，这不是一个难理解的问题。但“陷阱”给我的印象是，Hooks 挖了坑，只要不注意我就会掉坑里。这让我在使用时有种如履薄冰的感觉。直到我在外网查找相关资料时，才豁然开朗。老外更多的管这叫 Stale Closures，过期的闭包。看下图尽管我的关键词里有 trap，但搜索结果用到这个词的不多。\n而搜索 stale closure 就有很多的相关结果。\n这个问题的解决方案也很简单，把调用的 count 添加到 useEffect 依赖数组里面。 压根就没有什么“陷阱”，中文社区里有些文章直接被带偏，扯到要用 useRef 去了。。\n正确的说法应该是：useEffect 未正确添加依赖项，导致一直使用过期的闭包。想要避免，在使用 useEffect 时要注意依赖项。当然要在副作用函数里面找依赖项的开发体验确实很差，好在有 eslint-plugin-react-hooks ，可以直接配置 \u0026quot;react-hooks/exhaustive-deps\u0026quot;\n这个名词最大的问题在于，把锅甩给 Hooks，提升了 Hooks 使用的心智负担。Hooks 有它的规则，开发者遵循这些规则，才能很好的享用它。\n想起了以前 Javascript 一道经典面试题：\n1 2 3 4 5 for (var i = 1; i \u0026lt; 5; i++) { setTimeout( function () { console.log(i); }); } 输出结果全是 5。同样的反直觉，但鲜有 “setTimeout 陷阱”，“不要使用 setTimeout” 的说法。\n","description":"","id":2,"section":"posts","tags":["react"],"title":"React Hooks 没有闭包陷阱","uri":"https://c1xf.github.io/posts/react-hooks-%E6%B2%A1%E6%9C%89%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/"},{"content":"从 Angular 转到用 React Hooks 写项目经常会出现困惑，我代码写得没问题啊，咋就不能正常运行呢 ？😅 这里的 “没问题” 指的是在 JavaScript 语法上没问题，但在 Hooks 领域下是有问题的。比如下面这种代码：\n1 2 3 4 5 const [count, setCount] = useState(0) useEffect(() =\u0026gt; { setCount(count + 1) }) 代码只调用了一次 setCount ，实际运行却形成了死循环。\nReact Hooks 是为客户端场景量身定做的一套“函数式”解决方案。与 Hooks 有关的变量、函数，都不能只从代码的对错去分析运行结果。代码执行出错了肯定有问题，代码执行对了也不一定正确。正常 !== 正确\n用 JavaScript 语言的直觉写/看 Hooks，中间还要理解一层原理（比如闭包），很累，心智负担重。就像我要用眼前这台显示器，要想信号如何传输，画面如何显示？实际我的直觉是通电，插上信号线，就能正常工作。\n建立使用 React Hooks 的心智模型1，写/看到 Hooks 形成直觉，才能轻松愉快的开发项目。\n直觉是直接得到的感觉，即在经验和已有知识的基础上，不经过逻辑推理而直接迅速地认知事物的思维活动。对代码来讲，直觉是看到一串字符得到其运行结果，比如 setTimeout(cb,1000) = 1 秒后会执行 cb 函数，实际可能比 1s 要长。\n下面开始分析、实践，总结出 Hooks = what.\n客户端场景 客户端场景简单了说就是：状态 + 异步。其中异步又包括用户操作和发送请求等副作用。\nHooks 的“函数式”解决方案是：\nuseState 负责显示/更新状态 synthetic event 合成事件响应用户操作 useEffect 负责发送请求等副作用 至于其他 Hooks，部分功能类似，部分用来优化性能。\n合成事件（synthetic event）的读/写和原生事件类似。下面看看 useState 、useEffect\nuseState：组件函数非幂等的多次运行 useState(initialState) ，接收一个能得到 initialState 参数（可以是函数）。返回一个包含两个值的数组 [state, setState]。第一个值是当前状态，用来显示，第二个值是一个函数，接受 newState 作为参数，用来更新状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { useState } from \u0026#39;react\u0026#39; export default function App() { console.log(\u0026#39;App\u0026#39;) const [count, setCount] = useState(0) console.log(\u0026#39;count: \u0026#39;, count) const handleClick = () =\u0026gt; { console.log(\u0026#39;handleClick\u0026#39;) setCount(count + 1) } return ( \u0026lt;div\u0026gt; {count} \u0026lt;button onClick={handleClick}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 首次打开页面，按正常的函数执行，页面显示和控制台输出都没问题：\n清空控制台输出，点击 +1 按钮得到的结果，就和常规的函数有差别了，不只是输出 1 次 handleClick：\nApp 组件函数被重新执行了，count 打印的不再是 0，是 1，页面显示的 count 也是 1。\n继续点击 +1，App 组件函数又会重新执行，count 继续累加。经过实践观察我们可以得出以下结论：\n一次 setState 会触发一次组件函数的执行，且是非幂等的 initialState 在非第一次执行时会被忽略 在 setCount 之后输出 count 值，查看 count 是否发生变化：\nsetCount 之后 count 值仍然是当前状态 0，setCount 不是同步改变状态。\nsetState 更新状态是异步的 增加一个 state，并且和 setCount 同时 setState：\n点击 +1 按钮， App 组件函数只执行了一次。\n一个流程执行多次/多个 setState，只会更新一次 使用 useState 时，不能用函数式的幂等来理解函数组件，得以多次运行的非幂等来看。当然对于组件使用者而言，仍然是幂等的。\nuseEffect：副作用总管家 useEffect 负责管理副作用，具体包括副作用的执行时机和执行次数。\n既然是总管家，所有的副作用都应该写在 useEffect 里面。\nuseEffect(setup, deps?) 接收两个参数，一个必传的回调函数 setup、一个可选的依赖数组 deps，返回 undefined。\nsetup 函数在 render 后执行且至少执行一次。setup 返回的函数，会在组件 unmount 后执行 useEffect(() =\u0026gt; { return () =\u0026gt; {} }, [])。\ndeps 参数会影响 setup 函数的执行次数，规则如下：\nuseEffect(()=\u0026gt;{})，每次 render 后都执行 useEffect(() =\u0026gt; {}, [])，仅第一次 render 后执行 useEffect(() =\u0026gt; {}, [deps])，提供依赖项数组，第一次以及依赖项发生变化后执行 总结 经过一番时间实践观察 🕵，可以建立以下与 React Hooks 有关的直觉：\n客户端 = 状态 + 异步 const [state, setState] = useState(initialState) initialState = 在非第一次执行时会被忽略 state = 不可变的当前状态 setState(newState) = 使用 Object.is 比较 state 和 newState ，有变更则异步更新状态，触发一次组件函数的非幂等执行和 render。 多次/多个 setState(newState) = 更新一次 useEffect(setup, deps?) 所有的副作用都应该写在 useEffect 里面 setup = 在 render 后执行且至少执行一次 setup 返回函数 = 在组件 unmount 后执行 deps = setup 函数的执行次数 useEffect(()=\u0026gt;{}) = 每次 render 后都执行 useEffect(() =\u0026gt; {}, []) = 仅第一次 render 后执行 useEffect(() =\u0026gt; {}, [deps]) = 第一次以及依赖项发生变化后执行 回到开头的代码，可以直接翻译：每次 render 后都异步更新 count，触发一次组件函数的非幂等执行和 render，render 后都异步更新 count，触发一次组件函数的非幂等执行和 render，\u0026hellip; 得到了死循环的运行结论。\n1 2 3 useEffect(() =\u0026gt; { setCount(count + 1) }) 最后还有两条军法：\nHooks 只能在函数组件的顶级作用域使用 Hooks 只能在函数组件或者其它 Hooks 中使用 所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。\n不要再用 Javascript 语言的直觉写 React Hooks 了，那样只会收获反直觉。锤炼出 React Hooks 直觉，Happy Coding 😉\n心智模型是指人们头脑中对外界事物和现象的认知框架，包括对其属性、功能、关系等方面的认知。这些模型由我们的经验和学习所塑造，帮助我们理解、预测和解释世界。心智模型可以是简单的思维模式，也可以是较为复杂和抽象的概念模型。它们对我们的思考和行为产生重要影响，并在不同情境下不断更新和演化。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":3,"section":"posts","tags":["react"],"title":"使用 React Hooks 开发时的心智模型","uri":"https://c1xf.github.io/posts/%E4%BD%BF%E7%94%A8-react-hooks-%E5%BC%80%E5%8F%91%E6%97%B6%E7%9A%84%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B/"},{"content":"最近在朋友的安利下，认真学习了 React Hooks。之前简单了解过，当时的感受是，啥玩意？函数名加个 use 就能保持状态，取代生命周期啦。对于喜欢 kiss 的我来说有点接受不了，别误会是 Keep It Simple, Stupid 😘。这次认真接触后有了很大的改观，和 Hooks 带来收益相比，这点心智成本貌似也能接受？\n经过我司 CTO 的 洗脑后，我一直挺喜欢函数式编程 Functional programming，因为它够 Simple。但对于客户端来讲，页面充斥着接口返回的状态，用户操作的状态，把这些状态用对象管理起来，用面向对象编程 Object-oriented Programming 似乎更合理更容易理解。\n页面的数据是对象的属性，点击输入等事件绑定对象的方法，页面对象还有生命（周期）。带着这样的理解，在日常开发中我摸索出的最佳实践是 OOP 保持状态，FP 计算状态。假设页面两输入框，将输入的数值做加法运算，我会这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Addition { num1: number num2: number result: number handleAdd() { this.result = add(this.num1, this.num2) } } function add(n1, n2) { return n1 + n2 } 这样做的好处是，FP 的单元测试非常好些，只要单元测试保证 add 函数不出错，页面的状态就不会出错。同时其他页面出现相同逻辑，随时可以把 add 函数放到公共包里。\n但是页面的属性、方法、生命周期仍然是不好复用的，虽说可以抽象出 service 甚至直接抽象一个父类。但是业务千变万化，此刻合理抽象没多久可能就成了一种超前设计。这是 OOP 的一大痛点，抽象的重要前提是稳定，而业务是不断向前发展变化的。\n写了一大堆与 Hooks 无关的，主要讲我这几年使用 OOP 遇到问题：状态不能复用。在使用过 Hooks 之后，我看到了这个问题的解决方案。\nReact 社区的这张图直观地对比 Class 组件和使用 Hooks 的 Functional 组件，绿色、蓝色和黄色代表不同的业务功能。\n看完我直接 Hooks YYDS 啊。Class 组件中分散各处的业务逻辑，经过 Hooks 改造井然有序的聚合在了一起。这不就是组合优于继承吗，Greeting 组件 = 绿色业务 + 蓝色业务 + 黄色业务，简直完美啊。之前想怎么复用函数、属性、方法巴拉巴拉。。Hooks 轻松实现业务复用，直接按颜色把代码一抽就完事，这能不香吗 😍。\n然而命运的馈赠都早已暗中标好了价格 😂，在仔细的写了几个案例之后，我发现 Hooks 不光有理解成本、使用规则限制、闭包陷阱还有性能负担。使用 Angular、Vue 只需要在数据量大的页面关注性能，而 React Hooks 可以轻松写出死循环代码\n1 2 3 useEffect(() =\u0026gt; { setCount((count) =\u0026gt; count + 1) }) 但不管怎么样，围绕业务组织代码的吸引力太大了，接下来就尝试摸索出 React Hooks 的最佳实践，尽量降低使用的成本 🤠。\n","description":"","id":4,"section":"posts","tags":["react"],"title":"初识 React Hooks 的一些思考","uri":"https://c1xf.github.io/posts/%E5%88%9D%E8%AF%86-react-hooks-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"},{"content":"why webpack 小程序开发工具（官方文档）对 npm、typescript 独特的支持方式操比较繁琐。它的作用应该更类似于浏览器，运行编译结果。 使用 webpack 保证打包体验和 web 一致。如：编译错误信息的显示 打包内容 ts -\u0026gt; commonJS 模块化 scss -\u0026gt; wxss wxml -\u0026gt; wxml json -\u0026gt; json images -\u0026gt; images on server entry 配置 web 通常有 index.js 作为入口。微信小程序的有 app.js，但它没有关联任何页面代码文件，不能算作入口。\n页面的 js 代码之间没有相互关联，所有页面都注册在 app.json，组件也是通过 json 配置 usingComponents 关联。同时 js、wxml、wxss 之间也没有关联关系，靠相同的路径与文件名约定。因此将 app.json 配置为 entry。\n资源加载方案：\nts 资源通过 entry-plugin.ts 获取 app.json 所有的页面和组件的 ts 文件添加为 entry wxml、scss 以及图片等其他资源则通过 json.loader.js loadModule 加载 在默认配置下，会给每个 entry 都添加上 runtime 代码。但小程序运行时是单页应用，只需要一份 runtime 代码即可。runtimeChunk 需要配置为 single\nrequire 补丁：\n小程序不允许 require 一个变量，以下代码依赖运行时，无法解析出具体依赖：\n1 2 let m = \u0026#39;testa\u0026#39; require(m) 导致 webpack 生成的 js 在运行时引入模块报错：Error: module 'xxxx.js' is not defined。代码片段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // app.js var __webpack_exports__ = __webpack_require__.X( 0, [ \u0026#39;commons-api\u0026#39;, \u0026#39;commons-a\u0026#39;, \u0026#39;commons-e\u0026#39;, \u0026#39;commons-node_modules_j\u0026#39;, \u0026#39;commons-utils_c\u0026#39;, \u0026#39;commons-utils_validators_f\u0026#39;, ], () =\u0026gt; __webpack_exec__(\u0026#39;./app.ts\u0026#39;) ) // runtime.js:130 /******/ installChunk(require(\u0026#39;./\u0026#39; + __webpack_require__.u(chunkId))) 解决方案：在 runtime.js 中添加公共代码的 require 详见：require-patch-plugin.ts（注意：修改 cacheGroups 可能会影响该插件）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // runtime.js:3 // 添加前 var __webpack_modules__ = {} // 添加后 var __webpack_modules__ = Object.assign( require(\u0026#39;./commons-utils_validators_f.js\u0026#39;).modules, require(\u0026#39;./commons-api.js\u0026#39;).modules, require(\u0026#39;./commons-a.js\u0026#39;).modules, require(\u0026#39;./commons-e.js\u0026#39;).modules, require(\u0026#39;./commons-node_modules_j.js\u0026#39;).modules, require(\u0026#39;./commons-utils_c.js\u0026#39;).modules ) 图片处理 由于小程序包的大小限制，wxss 中也不能包含本地图片。图片资源需要上传至服务器，开发和生产模式下都需要。\n解决方案：\n服务器上图片资源不同的环境的区分，OSS 对应的目录如下： dev: weapp-dev staging、test: weapp-ts prod: weapp production 生产模式：在打包结束后，将 dist/static/images 目录上传至服务器，上传结束后移除。详见：upload-images.ts development 开发模式：手动上传 npm run manual-upload-images。如果有变动的图片较多，调整插件参数实现自动上传 ","description":"","id":5,"section":"posts","tags":["webpack","miniprogram"],"title":"小程序 webpack 打包方案","uri":"https://c1xf.github.io/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F-webpack-%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88/"},{"content":" 最近看到了两位大佬天花板级别的类型体操：\n用 TypeScript 类型运算实现一个中国象棋程序 - 徐飞 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器 - brambles 看完只能献上我的 🧎‍♂️。网上也出现一些 type-challenges 上的面试骚题，大部分是考察 infer 的应用。\n实际项目中，我也有使用 infer。具体场景是用在抽象不同业务的相同流程， 推断具体业务类型。infer 的强大在于可以通过模式匹配可以从泛型中提取到类型，总结有 4 种场景：\n对象属性类型 函数参数类型和返回值类型 Function Parameters and Return type 数组 Array 模板字符串 Template Literals 使用前注意：infer 只能出现 extends 条件类型1 语句中，且类型变量只能在 true 分支中使用。\n条件类型语法有点像 JavaScript 的三元运算 (condition ? trueExpression : falseExpression) ：\n1 SomeType extends OtherType ? TrueType : FalseType; 对象属性 condition 的写法是属性作为 key，值使用 infer ：{ prop : infer V }。下面代码从通用的接口类型中获取 todo 数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 interface ApiResponse\u0026lt;T\u0026gt; { code: number data: T } interface Todo { content: string completed: boolean } type TodosResp = ApiResponse\u0026lt;Todo[]\u0026gt; type GetRespData\u0026lt;T\u0026gt; = T extends { data: infer V } ? V : never type DataInTodoResp = GetRespData\u0026lt;TodosResp\u0026gt; // Todo[] 函数参数和返回值 写出函数类型声明 (...args: any[]) =\u0026gt; any 然后填空即可\n返回值类型\n1 type MyReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : never 参数类型\n1 2 3 4 5 type MyParameters\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...any: infer P ) =\u0026gt; any ? P : never 数组 一类仍然是模式匹配，通过解构赋值2，取数组第一个/最后一个的类型\n1 2 type First\u0026lt;T extends any[]\u0026gt; = T extends [infer F, ...any[]] ? F : never type Last\u0026lt;T extends any[]\u0026gt; = T extends [...any[], infer L] ? L : never 一类要使用递归，在类型系统中实现 JavaScript Array.includes 函数，解构取到第一个元素和由剩余元素组成的数组，第一个匹配成功返回 true，未匹配成功继续用剩下的数组匹配。\ntype Includes\u0026lt;T extends readonly any[], U\u0026gt; = T extends [infer F,...infer R] ? (Equal\u0026lt;F,U\u0026gt; extends true ? true : Includes\u0026lt;R,U\u0026gt;) : false 模板字符串 删除两段的空白字符串 Trim，解法是模板模式配合递归\n1 2 3 4 5 6 type Chars = \u0026#39; \u0026#39; | \u0026#39;\\n\u0026#39; | \u0026#39;\\t\u0026#39; type Trim\u0026lt;S extends string\u0026gt; = S extends `${Chars}${infer SS}` ? Trim\u0026lt;SS\u0026gt; : S extends `${infer SS}${Chars}` ? Trim\u0026lt;SS\u0026gt; : S 总结 4 个场景捋下来，使用 infer 提取类型的关键在于写出符合不同数据结构的模式，然后填空即可。日常业务开发，这些袋鼠摇基本够用了~ 🦘\nhttps://www.typescriptlang.org/docs/handbook/2/conditional-types.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":6,"section":"posts","tags":["typescript"],"title":"Typescript 使用 infer 的4种场景","uri":"https://c1xf.github.io/posts/typescript-%E4%BD%BF%E7%94%A8-infer-%E7%9A%844%E7%A7%8D%E5%9C%BA%E6%99%AF/"},{"content":" 最近重写了项目的支付中心组件。起因是项目经过几个月的开发和迭代，从开始的一种业务订单 + 一种支付方式，到现在变成了多种业务订单 + 多种支付方式 ，复杂度翻了几倍，原有的组件变得难以维护和扩展。刚好开发的新业务到了对接支付阶段，索性把它重写了。这次对复杂业务的重写让我深刻体会到了 Angular 依赖注入的强大和灵活 。\n业务场景 用户在我司网站上购买机票或者预订酒店，下单完成后会进到支付页面。支付页面根据用户信息获取其可用的支付方式，然后用户就可以按需选择支付方式完成支付。页面结构大体如图：\n订单页包含产品信息和支付中心组件，支付中心包含多个支付组件，可以切换支付方式，支付组件包含支付按钮。支付组件之间没有关联。当用户点下支付按钮时，大致会经过以下几个步骤：\n虚线部分表示不同产品/不同支付方式相应的流程会有差异， 😂 基本就没啥相同的。复杂程度 = 产品类型*支付方式\n实现方案 旧版的实现方案简单直接，把支付所需的订单信息层层传递到每个支付组件。这个方案的问题有两个：\n父组件依赖子组件的具体实现。支付组件有变更，订单组件要跟着改。 属性层层传递的写法啰嗦 依赖反转原则（Dependence Inversion Principle，DIP）提供了优化思路：\n高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 依赖抽象示意图：\n嗯，看似好像没啥问题。等等！光依赖抽象了，反转呢？没看到哪里有“反”啊。这里我只能感谢中文社区的翻译 😤。。来看 wikipedia 英文原版对 DIP 的解释（机翻）：\nA. 高级模块不应从低级模块导入任何内容。两者都应该依赖于抽象（例如，接口）。\nB. 抽象不应依赖于细节。细节（具体实现）应该取决于抽象。\n不应从低级模块导入任何内容！ 上图中的支付抽象定义在了支付模块，订单模块需要从支付模块导入。明显不符合规则！调整一下示意图：\n这样依赖抽象和反转就很明显的能看出来了 🙃。\n反转 是这一原则的精髓所在，订单模块和支付模块依赖关系对调了。从低级模块有什么，高阶模块就只能用什么，反转为由高阶模块提供信息，低级模块调用。\n这就好比食堂和下馆子的区别。去食堂吃饭，食堂当天炒了什么菜你就只能吃什么。下馆子则不同，想吃啥先下单（提供菜品信息），厨房拿到订单直接给你做。显然下馆子吃的更舒服，更能适应变化。\n具体实现 回到订单支付流程，现在看产品订单需要提供哪些信息。\n订单金额、订单号 验证订单流 完成订单的回调 抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // pending-order.ts import { Observable } from \u0026#39;rxjs\u0026#39; export abstract class PendingOrder { /** 支付金额 */ abstract get payAmount(): number /** 订单号 */ abstract get orderNo(): string /**支付前验证*/ abstract beforePay(): Observable\u0026lt;void\u0026gt; /** 支付完成 */ abstract payCompleted(): void } 订单实现取决于抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // flight-order.component.ts import { Component, forwardRef, OnInit } from \u0026#39;@angular/core\u0026#39; import { of } from \u0026#39;rxjs\u0026#39; import { tap } from \u0026#39;rxjs/operators\u0026#39; import { PendingOrder } from \u0026#39;../common/pending-order\u0026#39; @Component({ selector: \u0026#39;app-flight-order\u0026#39;, templateUrl: \u0026#39;./flight-order.component.html\u0026#39;, styleUrls: [\u0026#39;./flight-order.component.css\u0026#39;], providers: [ { provide: PendingOrder, useExisting: forwardRef(() =\u0026gt; FlightOrderComponent), }, ], }) export class FlightOrderComponent extends PendingOrder implements OnInit { constructor() { super() } ngOnInit() {} payCompleted() { console.log(\u0026#39;flight order pay completed\u0026#39;) } beforePay() { return of(null).pipe(tap(() =\u0026gt; console.log(\u0026#39;flight order before pay\u0026#39;))) } get payAmount() { return 9999 } get orderNo() { return \u0026#39;flight order no:fffffffffffffffffffffff\u0026#39; } } 支付模块依赖于订单模块的抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39; import { PendingOrder } from \u0026#39;../../common/pending-order\u0026#39; @Component({ selector: \u0026#39;app-balance-pay\u0026#39;, templateUrl: \u0026#39;./balance-pay.component.html\u0026#39;, styleUrls: [\u0026#39;./balance-pay.component.css\u0026#39;], }) export class BalancePayComponent implements OnInit { constructor(public order: PendingOrder) {} ngOnInit() {} handlePay() { console.log(\u0026#39;balance pay\u0026#39;) this.order .beforePay() .pipe() .subscribe((_) =\u0026gt; { this.order.payCompleted() }) } } 演示 demo：https://stackblitz.com/edit/angular-f7cueh，切换订单/支付按钮，点击“支付”查看控制台输出\n总结 撸完支付组件，感觉依赖反转原则（Dependence Inversion Principle）应用起来真是太妙了。订单页和支付组件解耦了不说，订单页还拥有了主动权，扩展性嗷嗷的。产品需求尽管加尽管变，小爷轻松给你实现 😎\n","description":"","id":7,"section":"posts","tags":["angular"],"title":"Angular 依赖注入重写支付组件","uri":"https://c1xf.github.io/posts/angular-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E7%BB%84%E4%BB%B6/"},{"content":"Why Vim vim - the ubiquitous text editor（无处不在的文本编辑器），一些操作系统都预装了 vim，在服务器上不用再安装文本编辑器，很多 IDE 有 vim 插件（emacs 也提供了 evil 插件），学 vim 的收益很高。\nvim 区分了 normal 模式和 insert 模式，一定程度上避免了误编辑。\nvim 基础 在 normal 模式和 visual 模式下，我们通过输入操作语句的缩写来达到目的，一个操作语句通常由 (数量)+动词+(介词)+名词 组成。\n名词 - 操作单元，基于 vim 对文档的抽象 - text object：\nw (word) s (sentence) p (paragraph) t (HTML tag) 引号或者各种括号所包含的文本称作一个文本块。 动词 - 需要做的操作：\nd (delete) r (replace) y (yank) c (change) p (paste) v (visual mode) i (insert) a (append) s 编辑动词的大写往往代表了一个操作语句\n介词 - 操作范围：\ni (inside) a (around) f (forward) t (to) 待确认 光标移动：\nw,W b,B e,E ge,gE hjkl g (go) f (find) % *,# `` 回到上一次的位置 \u0026rsquo;\u0026rsquo; 回到上一次位置的行首 光标移动依然还是比较慢，在实际应用过程中使用 vim-easymotion 插件，直接用 f(find)目标对应的符号跳转，这样最简单。\nVim 实战应用 默认的操作 d,c 等都会写入 register，我理解的是 vim 只有剪切，没有删除。这点实际用起来挺难受，做了一点映射配置：\n把默认的 d,c 映射为剪切到黑洞寄存器 ( black hole register ) 变成删除操作 \u0026lt;leader\u0026gt;+d,c 映射为默认的 d,c 变成剪切操作。 退出 INSERT 模式用 Ctrl + [（需要新加） esc 太远；配置 jj，中文输入时不方便 Ctrl+Shift+[ 利用扩展 macros 同时执行了“save“ 关闭部分 Control 快捷键 影响 mac 上通用的快捷键 禁用 undo/redo（待确定）、光标 trace Control + w 好用，修改设置 vim-surround ds、cs、S(visual mode)、ys(motion) fold line za,set vim.fixFold=true 中文输入环境下，配置好输入法切换\n中文输入切换 https://github.com/daipeihust/im-select#installation 参考地址 https://github.com/skywind3000/awesome-cheatsheets/blob/master/editors/vim.txt\n","description":"","id":8,"section":"posts","tags":["tools"],"title":"Vim 入门总结","uri":"https://c1xf.github.io/posts/vim-%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"},{"content":"使用 Angular 开发项目有一段时间了，这期间经历了我司复杂业务流程的毒打，好在逐渐掌握 RxJS 之后，开始应对自如 🤹。现在回过头看，必须得夸一句：响应式编程真香。\n然而我初学 RxJS 的体验并不友好，概念太多了。一上来就是流（stream）、观察者模式、迭代器模式、Pull、Push、Hot、Cold、单播、多播\u0026hellip; 。得，还没开始用，先被一堆名词给绕晕了。\n我们可以先搞明白为什么要“响应式”？非响应式有什么缺点？这里我把非响应式编程称为事件单点（point）处理。\n事件单点处理 单点处理思维是一种快速而简单的思考方式。在编写事件处理代码时，写明需要执行的具体步骤，以实现最终的结果。下面以 TODO List 为案例，页面有一个待办事项列表，可以输入关键字过滤，还有一个“隐藏已完成”的复选框\n在从服务端获取到待办列表、用户输入关键字和点击复选框时，页面的列表项要显示筛选后的结果。下面是核心部分的代码实现，服务端获取用 Promise 简单模拟一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Component({ selector: \u0026#39;my-app\u0026#39;, standalone: true, imports: [CommonModule], template: ` \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;To Do List\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input placeholder=\u0026#34;keyword\u0026#34; (input)=\u0026#34;handleKeywordChange($event)\u0026#34; /\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; (input)=\u0026#34;handleHideCompleted($event)\u0026#34; /\u0026gt; hide completed \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of items\u0026#34; [class.done]=\u0026#34;item.done\u0026#34;\u0026gt; {{ item.description }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; `, styles: [\u0026#39;li.done { text-decoration: line-through;color:grey }\u0026#39;], }) export class PointDemo { keyword = \u0026#39;\u0026#39; completedHid = false items: Item[] = null allItems: Item[] = null ngOnInit() { // 模拟服务端获取 Promise.resolve([ { description: \u0026#39;eat\u0026#39;, done: true }, { description: \u0026#39;sleep\u0026#39;, done: false }, { description: \u0026#39;play\u0026#39;, done: false }, { description: \u0026#39;laugh\u0026#39;, done: true }, ]).then((res) =\u0026gt; { this.allItems = res this.filterItems() }) } handleKeywordChange(ev: any) { this.keyword = ev.target.value this.filterItems() } handleHideCompleted(ev: any) { this.completedHid = ev.target.checked this.filterItems() } private filterItems() { if (this.allItems) { this.items = this.allItems.filter( (item) =\u0026gt; item.description.includes(this.keyword) \u0026amp;\u0026amp; (this.completedHid ? !item.done : true) ) } } } 重复出现的 this.filterItems() 让人闻到了不好的味道。每个事件发生后，变更相应的数据，然后按新的数据重新筛选待办列表。数据的消费过程，只能写在事件处理函数中。\n这就好比餐厅的厨师炒完一道菜，还要上菜，或者打包成外卖，或者做其他处理。这样厨师的压力会很大，一旦忙起来很容易出错。\n同样的，事件单点处理的方式，让事件处理函数的压力会随着需求增多而加大。数据的生产和消费耦合在了一起。\n响应式改造 在现实生活中，餐厅会配备服务员。厨师炒完菜，把菜放上餐台，服务员看到后会去上菜或打包，完成后续的步骤。这样厨师的压力大减。\n在 TODO List 例子中，我们也给它配备“餐台”和“服务员”试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 export class ObservableDemo { keyword$ = new BehaviorSubject(\u0026#39;\u0026#39;) completedHid$ = new BehaviorSubject(false) items: Item[] = null ngOnInit() { const allItems$ = from( Promise.resolve([ { description: \u0026#39;eat\u0026#39;, done: true }, { description: \u0026#39;sleep\u0026#39;, done: false }, { description: \u0026#39;play\u0026#39;, done: false }, { description: \u0026#39;laugh\u0026#39;, done: true }, ]) ) const waiter = ([allItems, keyword, completedHid]) =\u0026gt; { this.items = allItems.filter( (item) =\u0026gt; item.description.includes(keyword) \u0026amp;\u0026amp; (completedHid ? !item.done : true) ) } combineLatest([ allItems$, this.keyword$.asObservable(), this.completedHid$.asObservable(), ]).subscribe(waiter) } handleKeywordChange(ev: any) { this.keyword$.next(ev.target.value) } handleHideCompleted(ev: any) { this.completedHid$.next(ev.target.checked) } } （PS：以 $ 结尾是可观察对象的命名约定1）\n改造后增加了三个“餐台” 数据源，keyword$、completedHid$、allItems$，waiter 订阅这三个源，在接收到新数据时，重新过滤待办列表。同时在事件处理函数中，只需要发出新的数据。这样各司其职，就实现了生产数据和消费数据的解耦，代码逻辑更清晰易懂。\nAngular 提供了响应式表单 FormControl 和 异步 Pipe async，代码可以继续简化传送门\n现在可以回答最开始的提出的疑问，响应式编程的好处是：解耦，实现数据生产和消费的职能分离。\n升级流式思维 尝到了甜头，再来看看响应式编程的定义：响应式编程是一种面向数据流和变化传播的编程范式。\n数据流是把在时间上按顺序依次产生数据看作一个整体，它是一个可观察的序列。数据流的变化会自动地传播给依赖于它的组件，并触发相应的更新和反应。\nYour Mouse is a Database，RxJS 的作者 Erik Meijer 如是写到。\n客户端的职能是请求服务器数据和响应用户操作，通常响应结果 = 服务器数据 + 用户操作数据。但他们都是异步的，且一个是 XMLHttpRequest，一个是 Dom Event，两者并不能简单的相加。用 RxJS 把它们同化为“流”，就很好处理了。\n比如在之前 TODO List 改造案例中，就是把“列表的获取”、 “关键字的输入”、“复选框的点击” 当成 “请求流”、“输入流”和“点击流”，再通过 RxJS 提供合并操作符 combineLatest ，把分散的数据流合并到一起来使用，得到最终的响应结果，非常便利。\nRxJS 提供了 90 多种 操作符，可以对流进行创建、合并、拆分、转化等各种操作。“流”不代表一定得有多个数据，可以是一个，也可以是 EMPTY。把异步事件都当成流，才能发挥操作符的威力。\nPromise 经常被拿来和可观察序列（Observable）对比，它们都可以处理异步事件。但 Promise 在创建时立即执行，且最多只能提供一个值；而 Observable 是惰性的，有订阅才会执行，可以提供多个值。详见 Observables compared to promises。\n最后 关于响应式编程，不要纠结于它提出的各种概念，用它解决问题，优化代码，提升思维。当你足够熟练之后，那些概念自然而然就理解了。本文举了一个很简单的案例，实际开发中 RxJS 能让你轻松应对各种复杂场景。\nObservable 已经在 TC39 提案里了，虽然现在还是 Stage 1 征求意见阶段2。\nhttps://angular.io/guide/rx-library#naming-conventions-for-observables\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/proposal-observable/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":9,"section":"posts","tags":["angular"],"title":"Angular RxJS 响应式编程","uri":"https://c1xf.github.io/posts/angular-rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"content":"一直没找到装饰器（Decorator）合适的业务应用场景。今天恰巧在处理节流时灵机一动，这用装饰器来实现很棒棒啊。\n装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。\n装饰器对外表现是能力+1 或加强 💪，内部实现就是套娃。下面是一个简单的例子，展示装饰器扩展函数的套路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 原始函数 function greet(name) { console.log(`Hello, ${name}!`) } // 装饰器函数 function withExclamation(func) { return function (name) { func(name + \u0026#39;!\u0026#39;) } } // 使用装饰器函数来扩展原始函数 const decoratedGreet = withExclamation(greet) // 输出结果：Hello, World! decoratedGreet(\u0026#39;World\u0026#39;) 在这个例子中，withExclamation 函数是“装饰器”函数，它接受 greet 函数作为参数，并套住 greet 返回一个新函数。调用 greet 之前向 name 参数添加了一个感叹号。\n套路就是这么简单，下面看下节流和防抖的具体实现。\n节流装饰器函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const throttle = (wait) =\u0026gt; { let prev = Date.now() return (target, name, descriptor) =\u0026gt; { const func = descriptor.value if (typeof func === \u0026#39;function\u0026#39;) { descriptor.value = function (...args) { const now = Date.now() if (now - prev \u0026gt; wait) { func.apply(this, args) prev = Date.now() } } } } } 防抖装饰器函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const debounce = (wait) =\u0026gt; { let timer return (target, name, descriptor) =\u0026gt; { const func = descriptor.value if (typeof func === \u0026#39;function\u0026#39;) { descriptor.value = function (...args) { if (timer) clearTimeout(timer) timer = setTimeout(() =\u0026gt; { func.apply(this, args) }, wait) } } } } 调用方式：\n1 2 3 4 5 6 7 8 9 10 11 export class App { @throttle(500) handleClick() { console.log(\u0026#39;click\u0026#39;) } @debounce(500) handleInput(ev) { console.log(ev.target.value) } } 不影响原有业务，又优化了性能，美滋滋 🌸。\n装饰器通常搞些与业务直接关联不大的事，可以看看第三方库提供的装饰器，找找有没有能用到的：\nhttps://www.npmjs.com/package/lodash-decorators https://www.npmjs.com/package/core-decorators ","description":"","id":10,"section":"posts","tags":["typescript"],"title":"装饰器实现节流、防抖","uri":"https://c1xf.github.io/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"content":"Why 快捷键 使用快捷键的目的是为了日常操作的流畅，减少因为频繁操作鼠标导致思考中断。但是，太多的快捷键会导致记忆的压力大增，因此应该注意以下几个原则：\n只记录高频的操作。 没有形成肌肉记忆之前，寻找大脑记忆规律。 当觉得做某事很低效时，应该停下来，然后思考正确的高效方式来完成。 认识 MacOS 修饰键 修饰键（modifier key）指电脑键盘上的一些用于组合按键的特殊按键。在整理快捷键时，我发现不同修饰键有不同的应用逻辑：\n⌃（Control） 控制。显示器内容（可能）不会发生改变。例：光标移动。 ⌘（Command） 命令去做，显示器内容会发生改变。例：复制粘贴。 ⇧（Shift） 换档。例：Shift + a -\u0026gt; A。 ⌥（Option） 完全另外一种情况。例：Shift + a -\u0026gt; œ。 从 Windows 转到 MacOS 常常 Cmd 和 Ctrl 分不清。按以上总结的规律，遇到快捷键不知道该用 Ctrl 还是 Command 时，想想显示的内容要不要发生变化 🤔。\nMacOS Command–空格键：显示或隐藏搜索栏。 Command-逗号 (,)：打开当前 App 的偏好设置。 Command-h：隐藏当前的 App 的窗口。 Command-m：将当前的窗口最小化至“程序坞”。 Command-Tab：切换到下一个最近使用的 App。 Command-`：相同 App 窗口切换。 Command-w：关闭最前面的窗口。 Command-n：打开新窗口。 Command-t：打开新标签页。 Control-Command-q：立即锁定屏幕。 Control-Command-f：全屏使用 App。 Command-+ /Command\u0026ndash;：App 显示内容放大/缩小。 Finder 空格键：快速查看所选项。 Shift-Command-g：打开“前往文件夹”窗口。 Command-Delete：将所选项移到废纸篓。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 文稿编辑 增删改查：\nCommand-x：剪切所选项并拷贝到剪贴板。 Command-c：将所选项拷贝到剪贴板。 Command-v：将剪贴板的内容粘贴到当前文稿或 App 中。 Command-z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做。 Command-a：全选各项。 Command-f：查找文稿中的项目或打开“查找”窗口。 Command-g：再次查找：查找项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Control-h(D)：删除插入点左（右）边的字符。也可以使用 Delete 键。 Control-k：删除插入点与行或段落末尾处之间的文本。 Control-t：将插入点后面的字符与插入点前面的字符交换。 Control-Command–空格键：唤起表情包 🎃。 光标移动/选中：\nControl–A(E)：移至行或段落的开头（末尾）。 Control–F(B)：向前（后）移动一个字符。 Control–N(P)：下（上）移一行。 Shift-：可以配合移动命令选中。 Chrome F12/Option-Command-I：打开调试工具。 Shift-Command-C：选取元素。 Command-P：打开源文件。 Vimium：\nr：刷新。 f：定义可点击的元素。 x ：关闭当前页签。 yy：拷贝当前 URL。 yt：拷贝当前 TAB。 t：新建一个页签。Shift-t 搜索已经打开的页签。 p ：当前页打开剪切的 URL。Shift-p 新标签中页打开。 VSCode Command-K Command-S：全部快捷键。 Command-O：打开文件。 Command-P：跳转到文件。 Command-N：新建文件。Shift-Command-N 新建窗口。 Command-W：关闭文件。Shift- 关闭窗口。 Shift-Command-T：还原关闭的文件。 Command-K - Command-W：关闭全部文件。 Control-R：打开最近的项目。 Control-W：删除上一个单词。 Control-Tab：下一个文件。Shift-Control-Tab 上一个文件。 F1：显示命令框。 Command-B：切换侧栏显示/隐藏。 切换工作区：\nShift-Command-E：焦点切换到资源管理器 / 编辑区。 Shift-Command-C：打开集成终端（焦点在资源管理器）。 Shift-Command-F：焦点切换到文件搜索。Shift-Command-H 显示文件替换。 Control-~ ：焦点切换到终端 。Shift-Control-~ 新建终端。 Control-Shift-G：焦点切换到仓库管理/ 编辑区。 Command-：拆分编辑区 / 终端。 Control-Enter：在侧边打开文件。 编辑区光标：\nCommand-G：跳转行。 Control- _ ： 后退。Shift-Control- _ 前进。 Command-D：选词 / 下一个匹配项。 Command-F：打开搜索框。\nOption-Command-F：打开替换框。 Shift-Escape：关闭搜索框。 编辑区编辑：\nF2：变量重命名。 Command-Enter：向下插入一行。Shift-Command-Enter 向上插入一行。 Shift-Command-K：删除当前行。 Shift-Space：触发提示。（改） Command-.：显示修复选项。 Control + J ：将后面的行添加到当前行。 Command+/：行注释。 Option-Shift-A：块注释。 Option-Shift-O：整理引入。 Terminal Control-w remove the word backwards from cursor position Control-u clear the line Control-z Suspends what you are running in the background 参考地址 https://support.apple.com/zh-cn/HT201236\nhttps://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf\n","description":"","id":11,"section":"posts","tags":["tools"],"title":"MacOS 快捷键整理","uri":"https://c1xf.github.io/posts/macos-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"},{"content":" HTTP 缓存是优化网络性能的一种方式，可以减少资源加载时间并降低流量消耗。它也是新手大概率会踩的一个坑，因为我就是这么过来的 😂。分析原因有 2 点：\nHTTP 有默认的缓存策略。在没有给出 Cache-Control 时，给你整个启发式缓存，完全不可控。 广为流传的 HTML \u0026lt;meta http-equiv=\u0026quot;Cache-Control\u0026quot;/\u0026gt; 设置的缓存策略不可靠1，得在 Web 服务器上配置响应消息头 如果前端和运维都没关注缓存的设置，那项目上线后基本就要遭重了 💀。耳边会响起计算机领域的名言警句：\nThere are only two hard problems in Computer Science: cache invalidation, and naming things.（计算机科学只有两大难题，“让缓存失效”和“命名”）\n恰巧，HTTP 缓存两个全占了，它的部分命名也会让你感到困惑 😏\nHTTP 缓存基本原理 在浏览器请求资源时，服务器会响应一个 HTTP 报文。报文中含有响应头（response header），通过设置响应头中的缓存控制信息，可以指示浏览器是否缓存该资源并告诉浏览器缓存的有效期。\n有效期内（fresh）再次请求该资源将直接从本地缓存中读取，不再请求服务器（中文社区称之为强缓存）。 未设置有效期或有效期过后（stale），再次请求资源，会携带本地缓存的文件信息，询问服务器资源是否已经更新。如果信息一致，服务器返回 304，继续使用本地缓存，否则服务器返回最新的内容（中文社区称之为协商缓存）。 HTTP 缓存就像一个霸总 👨‍💼，喜欢用“强”的，不行再“协商”，还不行才放弃。\nHTTP 缓存消息头 Cache-Control：通用消息头字段，出现于 HTTP / 1.1。可以通过它在响应消息头中指定客户端的缓存机制。\n缓存方式：\nmax-age=\u0026lt;seconds\u0026gt; ： 缓存存储的周期（单位秒），超过这个时间缓存被认为过期 no-cache：可以缓存，但使用前要向服务器验证。 no-store：不可以缓存 缓存过期后：\nmust-revalidate：过期后必须向服务器验证后再使用 max-age=0, must-revalidate 效果和 no-cache 差不多。\n代理服务器缓存设置：\nCache-control: public // 代理服务器可以缓存 Cache-control: private // 代理服务器不可以缓存 Cache-control: proxy-revalidate // 与 must-revalidate 作用相同 Cache-control: s-maxage=\u0026lt;seconds\u0026gt; // 与 max-age 作用相同 Cache-control: no-transform // 代理服务器不得对资源进行转换或转变 其他缓存响应头字段：\nExpires 用来指定具体过期时间。但它和 Cache-Control: max-age 存在重叠的地方，且 max-age 优先级更高 Pragma HTTP/1.0 版本的通用消息头字段，通常考虑兼容性设置 Pragma: no-cache ，效果和 Cache-Control: no-cache 一致 缓存可以设置的值比较多，网上很多资料也是大乱炖，很容易让人感到困惑 😵。其实常用到的就 3 个 max-age、must-revalidate、no-cache\nHTTP 缓存验证 请求响应头里提供 Last-Modified、Etag 作为资源的时效信息，浏览器向服务器验证时会携带该信息，两个的差别如下：\nLast-Modified/If-Modified-Since 比对文件的最后变更时间，精确到秒 Etag/If-None-Match 为资源计算出的唯一标识符。比变更时间可靠，但有计算成本 制定 HTTP 缓存策略 缓存的原则其实很简单：\n会变更的资源每次使用缓存前向服务器验证：no-cache 不会变更的资源缓存时间尽可能长：max-age=31536000（一年） 比如 SPA 项目的 index.html 文件应该使用 no-cache：\n# nginx add_header Cache-Control \u0026#34;no-cache\u0026#34;; 其他资源文件名由 content-hash 生成的，不会变更使用 max-age：\n# nginx expires 365d; 不是由 content-hash 生成文件名的资源则酌情配置。\n浏览器刷新行为 上述的缓存是基于用户 再次打开网页 的行为，当用户 刷新网页 时，缓存的使用情况有所不同\nF5/Ctrl+R/点击刷新按钮 HTML：向服务器发起请求，请求头增加 Cache-Control: max-age=0、If-Modified-Since、If-None-Match， 验证缓存是否可用 其他资源文件 js、css、img 仍然使用缓存 (from memory cache) or (from disk cache) Ctrl+F5/Ctrl+Shift+R 强制刷新 所有资源忽略缓存，请求头增加 Cache-Control: no-cache，资源重新从服务器获取 浏览器的普通刷新只会重新验证网页缓存，网页内引入的资源不会验证。\n小结 HTTP 旨在尽可能多地缓存，面对缓存这道难题，在项目上线前缓存策略是必须考虑和配置好的：\n一次性资源，设置尽可能大的 max-age 会变更资源，设置 no-cache 能确定时效，设置 Expires、must-revalidate，注意与 max-age 的冲突 此外，在配置 Web 服务器消息头时，还有 🛡️ 安全相关 的设置需要注意： https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n参考资料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching https://stackoverflow.com/questions/1341089/is-there-a-meta-tag-to-turn-off-caching-in-all-browsers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":12,"section":"posts","tags":["http"],"title":"HTTP 缓存实践总结","uri":"https://c1xf.github.io/posts/http-%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"},{"content":" 在 Javascript 中，undefined 和 null 是若即若离的空值两兄弟 🧑‍🤝‍🧑（nullish value1）。我们有时候把它们视为两个不同的概念，有时候又把它们作相同的处理。\n概念不同 从数据角度讲，两者完全是两个概念：\nundefined 表示值不存在。内存空间找不到变量对应的值 null 则是一个字面量“空”。变量指向内存里表示“空”的地址 下面这张图能直观看到两者的差异：\n2\n给函数参数的设置默认值只对 undefined 生效\n1 2 3 4 5 6 7 function test(num = 1) { console.log(typeof num) } test() // \u0026#39;number\u0026#39; (num is set to 1) test(undefined) // \u0026#39;number\u0026#39; (num is set to 1 too) test(null) // \u0026#39;object\u0026#39; (num is set to null) 实际业务中也有区分的场景，比如表单有一数值项，用户不输入和输入后清空，页面显示该项都为空，但是前者表示用户没有任何操作，后者则表示用户填写值是 null。\nNullish 家族 一般情况下， ==（The Abstract Equality Comparison Algorithm 3）在比较前将两个被比较的值转换为相同类型。但 null == undefined 是特例，它俩的抽象相等比较的结果是 true。\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:\nIf x is null and y is undefined, return true. If x is undefined and y is null, return true. 两兄弟认祖归宗 Nullish 家族 👨‍❤️‍💋‍👨。Nullish 家族目前有 3 个技能：空值合并操作符 ??（Nullish coalescing operator4）、空值合并赋值 ??=（Nullish coalescing assignment）、可选链 (?.)（Optional chaining）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Nullish coalescing operator const foo = null ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; const boo = undefined ?? \u0026#39;default\u0026#39; // \u0026#34;default\u0026#34; // Nullish coalescing assignment const a = { duration: null } a.duration ??= 10 a.speed ??= 25 a // {duration: 10, speed: 25} // Optional chaining const greet = null greet?.() // undefined const sing = undefined sing?.() // undefined 把它们放到一个家族里，个人感觉是为了精简啰嗦的判断语法，Nullish 家族的技能都可用其它方式实现。但因为实际业务中它俩同时出现的频率实在太高，索性整合到一起。\n比如表单有一数值项和根据该数值计算得到的结果。数值是 null 和 undefined 时可能不显示结果。\nundefined 的历史 以下内容截取至 undefined 与 null 的区别 - 阮一峰\n1995 年JavaScript 诞生之初像 Java 一样，只设置了 null 作为表示\u0026quot;无\u0026quot;的值。\n根据 C 语言的传统，null 被设计成可以自动转为 0。\n1 2 Number(null) // 0 5 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。\n首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示\u0026quot;无\u0026quot;的值最好不是对象。\n其次，JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。\n因此，Brendan Eich 又设计了一个 undefined。\nJavascript 设计之初是运行在客户端的动态解释型语言，对数据没有约束力，所以也需要有不存在这一概念。\n有点奇怪的 null 奇怪的类型，null 是原始类型（primitive ）中的一员，但 typeof null 的结果是 object。嘿，这其实是大佬留下的一坨 💩5。JavaScript 值包含类型标记和值。 000 表示对象类型，而 null 刚好是 32 个 0 。\n不行，这坨我吃不下。一定要拿到 null 类型（当然也可以用 === strict equality）\n1 Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; 奇怪的数值转换，这是只能吃的一坨~ 6\n1 2 Number(null) // 0 null == 0 // false 原型链的的终点是 null 7\n1 Object.prototype.__proto__ // null 总结 undefined 和 null 从数据角度看，有本质的不同：null 是空值，undefined 是不存在。如果业务上需要明确区分，在提交数据时应该注意。而在客户端消费数据时，两个都是 无效值，可以使用 Nullish 家族技能，用更简洁的语法实现需求。\nhttps://developer.mozilla.org/en-US/docs/Glossary/Nullish\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-11.9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://2ality.com/2013/10/typeof-null.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://262.ecma-international.org/5.1/#sec-9.3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://tc39.es/ecma262/#sec-properties-of-the-object-prototype-object\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":13,"section":"posts","tags":["javascript"],"title":"undefined 和 null  那些事","uri":"https://c1xf.github.io/posts/undefined-%E5%92%8C-null-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"content":" Hugo 世界上最快的建站框架\n现在工具很多，要搭建个人博客并非难事。也因为多，时间可能浪费在了选择上，本文主要记录搭建过程中我的一些选择，供读者的参考\nHugo 的安装与使用 Windows 安装方式有几种。 这里我的选择的是 下载二进制文件 + 配置环境变量。注意最好选择带 extened 的版本。我使用的版本：hugo_extended_0.102.3_Windows-64bit.zip\n配置环境变量时注意是编辑 Path 变量，增加解压后 hugo.exe 所在的目录。配置好之后，查看是否正确安装\n1 2 $ hugo version hugo v0.102.3-b76146b129d7caa52417f8e914fc5b9271bf56fc+extended windows/amd64 BuildDate=2022-09-01T10:16:19Z VendorInfo=gohugoio 安装好之后，使用 hugo help 查看所有的命令。一般常用的只有三个：\n初始化：hugo new site my-blog 本地预览：hugo server 打包：hugo hugo new site my-blog 初始化之后可以看到以下信息：\n1 2 3 4 5 6 7 8 9 10 11 12 Congratulations! Your new Hugo site is created in C:\\git\\hugo_blog\\my-blog. ​ Just a few more steps and you\u0026#39;re ready to go: ​ 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. ​ Visit https://gohugo.io/ for quickstart guide and full documentation. 此时执行 hugo server 看到的是一片空白。将心怡的主题下载到 themes 目录下，并将 exampleSite 的内容替换到根目录。再次运行 hugo server，此时可能收获报错\n1 2 3 4 5 6 7 Start building sites … hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio ERROR 2021/08/08 15:05:14 Failed to get JSON resource \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: Get \u0026#34;https://api.twitter.com/1/statuses/oembed.json?id=1085870671291310081\u0026amp;omit_script=true\u0026#34;: dial tcp 162.125.2.6:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config: ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] Error: Error building site: \u0026#34;C:\\git\\hugo_blog\\my-block\\content\\blog\\rich-content.md:1:1\u0026#34;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file. Built in 37375 ms rich-content.md 文件内通常会有 youtube 或者 twitter 的内容，移除它们。再次运行 hugo server 就可以看到站点了。后续按主题的文档进行配置即可。\n搭建目标 好看，让人有持续输出的动力 安全，内容不会丢失 方便，专注内容创作 沟通，读者可以留言方便沟通 好看并不只是美观，像我的内容以文字和代码为主，想要良好的阅读体验，内容就不能过宽。此外我希望导航的结构清晰方便翻阅，有少量的个人元素但不影响阅读，有搜索功能等。Hugo 提供了一些主题 https://themes.gohugo.io/\n安全起见，我选择把内容托管在最大的同性交友社区 Github，同时利用 Github Actions 实现推送自动发布。我使用的是 https://github.com/peaceiris/actions-gh-pages\n评论留言使用 https://utteranc.es/。gitment 配置麻烦，还用不了 Error: Bad credentials，可能是姿势哪里不对\n总结 hugo 版本：hugo_extended_0.102.3_Windows-64bit.zip 使用 exampleSite 时注意外链 自动发布 github actions： https://github.com/peaceiris/actions-gh-pages 评论留言： https://utteranc.es/ 参考地址 使用 hugo 生成静态博客并部署在 GitHub 上：https://zhuanlan.zhihu.com/p/397612900 ","description":"","id":14,"section":"posts","tags":["tools"],"title":"Hugo + Github Pages 搭建个人博客","uri":"https://c1xf.github.io/posts/hugo-+-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":15,"section":"","tags":null,"title":"About","uri":"https://c1xf.github.io/about/"},{"content":"JavaScript this 在全局上下文中，this 指向全局对象（Web 浏览器上的window对象或 Node.js 上的global对象）。在函数上下文中，this 指向函数的调用者。可以通过 bind、apply、call 修改 this 的指向。\n箭头函数不提供它们自己的 this 绑定（它保留封闭词法上下文的 this 值）。\nnew new 运算符用来创建对象实例。当使用 new 关键字调用函数时，该函数将用作构造函数。 new 将做以下事情：\n创建一个空白的纯 JavaScript 对象 将空白的对象的原型指向构造函数的原型 使用给定的参数执行构造函数，将空白对象绑定为 this 上下文 如果构造函数返回一个非原始值，这个返回值将成为整个 new 表达式的结果。如果构造函数不返回任何内容或返回原始值，则返回新创建的对象。 原型链 原型是 JavaScript 对象相互继承特性的一种机制。1每个对象都有一个称为原型的内置属性。原型本身也是一个对象，所以原型会有自己的原型，这就形成了原型链。原型链的终点是 null。\n访问一个对象的属性时，如果在对象本身中找不到该属性，就会在原型中搜索该属性。如果仍然找不到该属性，那么就搜索原型的原型，以此类推，直达找到该属性，或者找到达链的末端，在这种情况下，返回 undefined。\n闭包（Closure） 闭包是指有权访问另一个函数作用域中变量（除了 this 和 arguments）的函数2。其原理是函数在词法解析阶段按词法作用域创建作用域链（scope chain）。作用域链的第一级是当前代码所在的执行环境，最后一级是全局执行环境。函数执行过程中，变量标识符的解析是沿着作用域链一级一级地搜索标识符，直到找到标识符为止（如果找不到，通常会报错）。\n由于 JavaScript 没有块级作用域，只要全局作用域和函数作用域，闭包是模块化开发的基础。使用闭包要注意循环引用带来的内存泄露问题。\n事件循环（event loop ） 事件循环 event loop 描述的是 JavaScript 宿主环境的运行时模型。它负责协调用户交互、脚本执行、UI 渲染、网络请求等事件。运行机制如下：\n所有同步任务都在主线程上执行，形成一个执行栈（Execution Context Stack） 主线程之外，还存在一个任务队列（Task Queue），异步任务的运行结果会在任务队列中添加对应事件 执行栈中的所有同步任务执行完毕，将任务队列的事件读取到执行栈中执行 主线程不断重复以上步骤 异步任务分为两种，微任务（MicroTask）和宏任务（MacroTask），微任务的优先级高于宏任务。\n宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。\nCSS（Cascading Style Sheets） 盒子模型（box model） CSS 盒子模型描述的是浏览器布局时，为元素生成的矩形框（box），它由四个部分组成：\ncontent，内容 padding，内边距 border，边框 margin，外边距 3\n通常需要关注的是，元素的宽高计算规则，可以通过 box-sizing 属性定义：\ncontent-box （默认值）：元素的 width/height 不包含 padding，border border-box：元素的 width/height 包含 padding，border 块级格式上下文（Block formatting context） 格式化上下文， 是 CSS 中排版的概念，不同的格式有不同的布局规则。BFC是一个完全独立的布局环境，里面的子元素不会影响到外面的布局。通常用来解决：\nfloat 脱离文档流高度塌陷 margin 塌陷：父子元素垂直方向的 margin 取最大值 margin 合并：并列的兄弟元素垂直方向的 margin 取最大值。 em/px/rem/vh/vw px，表示像素绝对长度单位\nem，相对字体大小的长度单位，\nrem，相对根元素 html 的字体大小的长度单位，自适应布局方案之一\nvw/vh，根据窗口的高度/宽度，分成 100 等份，也是自适应布局方案之一\n%，相对父元素的尺寸\n自适应方案：容器使用 vw，字体内容继续使用 px。\n1 2 3 @function vw($px) { @return ($px / 750) * 100vw; } dpr（devicePixelRatio） 是 css 像素与物理像素（devicePixel）的比率。1 倍的位图在 dpr 为 2 的设备上会显示模糊，就是因为多出了一些物理像素需要渲染 ，触发图像缩放算法导致图片模糊。还有高清屏绘制 canvas，需要用 dpr 校正分辨率。\n推荐阅读：\n重新認識 Pixel、DPI / PPI 以及像素密度\nTowards A Retina Web\nDOM 事件冒泡和事件捕获 事件流描述的是页面元素接收时间的顺序。事件冒泡（event bubbling）是事件开始时由最具体的元素接收，然后逐级向上传播。事件捕获（event capturing）是事件开始时由最外层元素接收，然后逐级向下到最具体的元素。\nDOM 事件流规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n利用事件冒泡机制可以实现事件委托来提升性能，有大量子元素要绑定相同事件时，可以讲将事件绑定到父元素，并让子元素上发生的事件冒泡到父元素。\nhttps://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《JavaScript 高级程序设计-第 3 版》P178\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.w3.org/TR/CSS2/box.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":16,"section":"posts","tags":null,"title":"前端面试知识点","uri":"https://c1xf.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"content":"最近要准备面试，数据结构与算法又得刷一刷了。坦白了讲，平时都是客户端开发，这块实战经验不多。客户端通常不会请求到大量的数据，数据量太少，也就没有用数据结构和算法优化的必要。但这东西是编程领域不会过时的基础，认真学习总结一下还是很有必要。\n复杂度 谈数据结构与算法，是想优化代码的运行效率。复杂度是代码运行效率的度量指标，代码执行过程中会消耗时间和存储空间，所以需要衡量的就是代码运行的时间复杂度和空间复杂度。\n通常用大 O 表示法（Big O notation）来描述算法的复杂度，它告诉我们算法在最坏情况下的运行时间如何随着输入数据量的增长而变化。常见的大 O 表示法例子有：\nO(1) 常数复杂度。所需资源与问题规模无关，例如，在数组中查找特定索引的元素 O(log n) 对数复杂度。每次迭代后，问题规模减半。例如，二分查找算法，它在每次迭代后将搜索区间缩小一半 O(n) 线性复杂度。所需资源与问题规模成正比。例如，遍历一个数组或列表中的所有元素 O(n log n) 线性对数复杂度。例如归并排序和快速排序。这类算法在处理问题规模为 n 时，实际上处理了 log n 级别的子问题 O(n^2) 平方复杂度。对于大小为 n 的输入数据，所需资源呈平方级增长。一般来说，这是嵌套循环结构的表现，例如冒泡排序和选择排序等 O(2^n) 指数复杂度 O(n!) 阶层复杂度 1\n通常，复杂度的计算方法遵循 2 个原则：\n复杂度与具体的常系数无关。例如 O(n) 和 O(2n) 表示的是同样的复杂度 多个复杂度相加的时候，选择高者作为结果。例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。 时间和空间并非等价。通常来讲，时间复杂度比空间复杂度“昂贵”。钱可以买空间，买不了时间~\n复杂度优化思路 复杂度优化可以拆分为 3 个步骤：\n暴力破解。在没有任何时间、空间约束下，完成代码任务的开发。 检查无效操作。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。 时/空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。 例题：假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。\n第一步：暴力破解，遍历取值区间内的所有值。复杂度 0(n^3)\n1 2 3 4 5 6 7 8 9 10 11 12 13 function func() { var count = 0 for (var i = 0; i \u0026lt;= 100 / 7; i++) { for (var j = 0; j \u0026lt;= 100 / 3; j++) { for (var k = 0; k \u0026lt;= 100 / 2; k++) { if (i * 7 + j * 3 + k * 2 == 100) { count += 1 } } } } console.log(count) } 第二部：检查无效操作，查看 for 循环是否可以优化。当 i 的值为 14 时，j 不需要遍历到 33；同时当 i、j 值确定后，k 值不需要遍历，只需要检查余值是否大于等于 0 且能被 2 整除\n1 2 3 4 5 6 7 8 9 10 11 function func() { var count = 0 for (var i = 0; i \u0026lt;= 100 / 7; i++) { for (var j = 0; j \u0026lt;= (100 - i) / 3; j++) { if (100 - i * 7 - j * 3 \u0026gt;= 0 \u0026amp;\u0026amp; (100 - i * 7 - j * 3) % 2 === 0) { count += 1 } } } console.log(count) } 第三部：时/空转换。该题只有一个常量 100，没有用数据结构优化的空间。\n数据结构 数据结构指的是组织、管理和存储数据的方式。不同的数据结构在解决特定问题时会产生不同的效率。以下列举了一些常见的数据结构：\nArray 数组：顺序存储的连续数据元素 Linked List 链表：分散存储的非连续数据元素，通过指针连接 Stack 栈：先进后出（FILO）原则的线性数据结构 Queue 队列：先进先出（FIFO）原则的线性数据结构 Hash Table 哈希表：根据键值对快速查找相应元素的无序数据结构 Binary Tree 树：分层和分支的有向无环图结构，通常用于表示分层关系 Graph 图：顶点和边组成的复杂网络结构，适用于表示多对多关系 除了 Graph 图以外，其他数据结构的空间复杂度都是 O(n)。数据基本操作只有 3 个，分别是增、删、查，不同数据结构的操作时间复杂度不同：\n增/删 查 Array 数组 O(n) O(1) Linked List 链表 O(1) O(n) Stack 栈/Queue 队列 O(1) O(n) Hash Table 哈希表 O(1) O(1) Binary Tree 树 O(logn) O(logn) 常见算法 排序算法 排序是让一组无序数据变成有序的过程。衡量一个排序算法的优劣，除了时间复杂度、空间复杂度，还有稳定性：相等的数据，在排序之后，顺序是否能保证不变\n冒泡排序（Bubble Sort） 冒泡排序（Bubble Sort）从第一个数据开始，依次比较相邻元素的大小。如果前者大于后者，则进行交换操作，把大的元素往后交换。每一次排序的最后一个数，下次排序不再参与比较。\n越大的元素会经由交换慢慢\u0026quot;浮\u0026quot;到数列的右侧。\n2\n助记码：3\n1 2 3 i∈[0,N-1) //循环N-1遍 j∈[0,N-1-i) //每遍循环要处理的无序部分 swap(j,j+1) //两两排序（升序/降序） 代码：\n1 2 3 4 5 6 7 8 9 10 11 function bubbleSort(arr) { for (var i = 0; i \u0026lt; arr.length - 1; i++) { for (var j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { var temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } } } 冒泡排序的性能：时间复杂度 O(n^2)，空间复杂度 O(1)，数据相等时元素不交换，是稳定排序算法。\n插入排序（Insertion Sort） 插入排序（Insertion Sort）和打扑克牌时，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。\n将第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n取出未排序序列的第一个元素。在有序序列中从后向前扫描，如果扫描的元素大于未排元素，将该元素移到下一位置。直到已排元素小于或者等于未排元素。\n代码：\n1 2 3 4 5 6 7 8 9 function insertSort(arr) { for (var i = 1; i \u0026lt; arr.length; i++) { var temp = arr[i] for (var j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp; j--) { arr[j + 1] = arr[j] } arr[j + 1] = temp } } 插入排序的性能：时间复杂度 O(n^2)，空间复杂度 O(1)，数据相等时元素不交换，是稳定排序算法。\n归并排序（Merge Sort） 归并排序（Merge Sort）有递归版（Top-down）和迭代版（Bottom-up）两种实现，其中递归版比较容易理解。采用分治法:\n分割：递归地把当前序列平均分割成两半，直到不可分割为止。 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并） 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function mergeSort(arr) { var len = arr.length if (len \u0026lt; 2) { return arr } // 分割 var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle) // 合并 return merge(mergeSort(left), mergeSort(right)) } function merge(left, right) { var result = [] while (left.length \u0026amp;\u0026amp; right.length) { if (left[0] \u0026lt;= right[0]) { result.push(left.shift()) } else { result.push(right.shift()) } } while (left.length) result.push(left.shift()) while (right.length) result.push(right.shift()) return result } 归并排序的性能：时间复杂度 O(n*logn)，空间复杂度 O(n)，数据相等时元素不交换，是稳定排序算法。\n快速排序（Quick Sort） 快速排序法是使用最广泛的排序算法，其原理也是分治法。\n在数据集之中，选择一个元素作为\u0026quot;基准\u0026quot;（pivot）。 所有小于\u0026quot;基准\u0026quot;的元素，都移到\u0026quot;基准\u0026quot;的左边；所有大于\u0026quot;基准\u0026quot;的元素，都移到\u0026quot;基准\u0026quot;的右边。 对\u0026quot;基准\u0026quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 4\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr } // 选择基准 var pivotIndex = Math.floor(arr.length / 2) var pivot = arr.splice(pivotIndex, 1)[0] // 按基准分组 var left = [] var right = [] for (var i = 0; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; pivot) { left.push(arr[i]) } else { right.push(arr[i]) } } // 重复以上步骤 return quickSort(left).concat([pivot], quickSort(right)) } 上述为简单版本，空间复杂度 O(n)。原地（in-place）分割版本空间复杂度 O(1)，但不稳定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function quickSort(arr, low, high) { if (low \u0026gt;= high) { return } var i = low, j = high, pivot = arr[low], temp while (i \u0026lt; j) { // 先看右边，依次往左递减，找到比基准小的值 while (arr[j] \u0026gt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) { j-- } // 再看左边，依次往右递增，找到比基准大的值 while (arr[i] \u0026lt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) { i++ } // 交换位置 temp = arr[j] arr[j] = arr[i] arr[i] = temp } // 基准值与较小值互换 arr[low] = arr[i] arr[i] = pivot // 递归调用左半数组 quickSort(arr, low, j - 1) // 递归调用右半数组 quickSort(arr, j + 1, high) } 快速排序的性能：时间复杂度 O(n*logn)，最坏时间复杂度 O(n^2)，空间复杂度 O(1)，分区过程涉及交换操作，是不稳定的排序算法。\n递归 递归的数学模型是数学归纳法，使用递归的前提条件：\n可以拆解为求解思路完全相同的子问题； 存在终止条件。 斐波那契数列（Fibonacci） 斐波那契数列：某个数等于它前面两个数的和。例：0，1，1，2，3，5，8，13，21，34，55，89，144。写一个函数，输入 n，输出斐波那契数列中第 n 位的元素。\n子问题 a[n+2] = a[n+1] + a[n] 终止条件： n 为 1 或 2 代码：\n1 2 3 4 5 6 7 8 9 function fibonacci(n) { if (n === 1) { return 0 } if (n === 2) { return 1 } return fibonacci(n - 2) + fibonacci(n - 1) } 汉诺塔（Tower of Hanoi） 三根杆子 x，y，z。x 杆上有 n (n\u0026gt;1)个穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 z 杆：\n每次只能移动一个圆盘； 大盘不能叠在小盘上面。 问题描述：\n把从小到大的 n-1 个盘子，从 x 移动到 y； 接着把最大的一个盘子，从 x 移动到 z； 再把从小到大的 n-1 个盘子，从 y 移动到 z。 代码：\n1 2 3 4 5 6 7 8 9 10 function hanio(n, x, y, z) { if (n == 1) { console.log(\u0026#39;移动: \u0026#39; + x + \u0026#39; -\u0026gt; \u0026#39; + z) return } else { hanio(n - 1, x, z, y) console.log(\u0026#39;移动: \u0026#39; + x + \u0026#39; -\u0026gt; \u0026#39; + z) hanio(n - 1, y, x, z) } } https://www.cnblogs.com/lshedward/p/10428455.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.runoob.com/w3cnote/bubble-sort.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://zh.wikipedia.org/zh-hans/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":17,"section":"posts","tags":null,"title":"数据结构与算法","uri":"https://c1xf.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]